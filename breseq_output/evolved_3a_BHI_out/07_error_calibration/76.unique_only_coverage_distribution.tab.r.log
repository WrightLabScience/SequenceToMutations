
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | 3a-_BHI_c50_out/07_error_calibration/76.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | 3a-_BHI_c50_out/output/calibration/76.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.00220541 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 18 to 40.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  29.84158  Size:  10000 
18   40 
29.84158   10000 
18   40 
29.84158   10000 
18   40 
29.84161   10000 
18   40 
29.84158   10000.01 
18   40 
29.84558   10000 
18   40 
29.84561   10000 
18   40 
29.84558   10000.01 
18   40 
39.43928   10000 
18   40 
39.43932   10000 
18   40 
39.43928   10000.01 
18   40 
34.60059   10000 
18   40 
34.60063   10000 
18   40 
34.60059   10000.01 
18   40 
35.02945   10000 
18   40 
35.02949   10000 
18   40 
35.02945   10000.01 
18   40 
34.99993   10000 
18   40 
34.99996   10000 
18   40 
34.99993   10000.01 
18   40 
35.00004   10000 
18   40 
35.00007   10000 
18   40 
35.00004   10000.01 
18   40 
35.00004   10000 
18   40 
35.00007   10000 
18   40 
35.00004   10000.01 
Fit Mean:  35.00004  Size:  10000  Code:  2 
Try Mean:  29.84158  Size:  1000 
18   40 
29.84158   1000 
18   40 
29.84158   1000 
18   40 
29.84161   1000 
18   40 
29.84158   1000.001 
18   40 
29.8455   1000 
18   40 
29.84553   1000 
18   40 
29.8455   1000.001 
18   40 
38.91871   999.9993 
18   40 
38.91875   999.9993 
18   40 
38.91871   1000 
18   40 
34.67224   999.9982 
18   40 
34.67228   999.9982 
18   40 
34.67224   999.9992 
18   40 
35.04458   999.9976 
18   40 
35.04462   999.9976 
18   40 
35.04458   999.9986 
18   40 
35.0225   999.9971 
18   40 
35.02254   999.9971 
18   40 
35.0225   999.9981 
18   40 
35.02254   999.9966 
18   40 
35.02258   999.9966 
18   40 
35.02254   999.9976 
18   40 
35.02571   999.9129 
18   40 
35.02574   999.9129 
18   40 
35.02571   999.9139 
18   40 
35.02892   999.7433 
18   40 
35.02895   999.7433 
18   40 
35.02892   999.7443 
18   40 
35.03531   999.1523 
18   40 
35.03535   999.1523 
18   40 
35.03531   999.1533 
18   40 
35.04498   997.6251 
18   40 
35.04502   997.6251 
18   40 
35.04498   997.6261 
18   40 
35.06133   993.3577 
18   40 
35.06136   993.3577 
18   40 
35.06133   993.3587 
18   40 
35.0885   981.8834 
18   40 
35.08853   981.8834 
18   40 
35.0885   981.8844 
18   40 
35.13721   949.7897 
18   40 
35.13725   949.7897 
18   40 
35.13721   949.7906 
18   40 
35.24161   850.2383 
18   40 
35.24164   850.2383 
18   40 
35.24161   850.2392 
18   40 
35.81698   192.0314 
18   40 
35.81701   192.0314 
18   40 
35.81698   192.0316 
Fit Mean:  59.02616  Size:  -25202.84  Code:  1 
Try Mean:  29.84158  Size:  100 
18   40 
29.84158   100 
18   40 
29.84158   100 
18   40 
29.84161   100 
18   40 
29.84158   100.0001 
18   40 
29.84488   99.99997 
18   40 
29.84491   99.99997 
18   40 
29.84488   100.0001 
18   40 
36.41157   99.95038 
18   40 
36.41161   99.95038 
18   40 
36.41157   99.95048 
18   40 
35.31123   99.91634 
18   40 
35.31127   99.91634 
18   40 
35.31123   99.91644 
18   40 
35.31922   99.8863 
18   40 
35.31925   99.8863 
18   40 
35.31922   99.8864 
18   40 
35.41695   99.12243 
18   40 
35.41698   99.12243 
18   40 
35.41695   99.12253 
18   40 
35.53626   97.35532 
18   40 
35.5363   97.35532 
18   40 
35.53626   97.35542 
18   40 
35.81597   90.8185 
18   40 
35.81601   90.8185 
18   40 
35.81597   90.81859 
18   40 
36.74053   62.46781 
18   40 
36.74057   62.46781 
18   40 
36.74053   62.46787 
18   40 
38.75428   1.07961 
18   40 
36.9465   56.18904 
18   40 
36.94654   56.18904 
18   40 
36.9465   56.1891 
Fit Mean:  39.75049  Size:  -27.45756  Code:  1 
Try Mean:  29.84158  Size:  10 
18   40 
29.84158   10 
18   40 
29.84158   10 
18   40 
29.84161   10 
18   40 
29.84158   10.00001 
18   40 
29.84322   10.00004 
18   40 
29.84325   10.00004 
18   40 
29.84322   10.00005 
18   40 
37.51254   12.59632 
18   40 
37.51258   12.59632 
18   40 
37.51254   12.59634 
18   40 
39.52184   13.45187 
18   40 
39.52188   13.45187 
18   40 
39.52184   13.45189 
18   40 
39.90727   13.29391 
18   40 
39.90731   13.29391 
18   40 
39.90727   13.29392 
18   40 
41.61899   11.76878 
18   40 
41.61903   11.76878 
18   40 
41.61899   11.76879 
18   40 
51.18804   1.468194 
18   40 
42.57589   10.73872 
18   40 
42.57594   10.73872 
18   40 
42.57589   10.73873 
18   40 
52.29159   0.3006476 
18   40 
43.54746   9.694916 
18   40 
43.54751   9.694916 
18   40 
43.54746   9.694926 
Fit Mean:  61.11301  Size:  -7.832315  Code:  1 
Try Mean:  29.84158  Size:  1 
18   40 
29.84158   1 
18   40 
29.84158   1 
18   40 
29.84161   1 
18   40 
29.84158   1.000001 
18   40 
29.8419   1.000949 
18   40 
29.84193   1.000949 
18   40 
29.8419   1.00095 
18   40 
340.5361   581.2093 
18   40 
107.3944   145.827 
18   40 
41.91255   23.54238 
18   40 
41.91259   23.54238 
18   40 
41.91255   23.5424 
18   40 
37.10711   15.0313 
18   40 
37.10715   15.0313 
18   40 
37.10711   15.03132 
18   40 
38.01714   16.49928 
18   40 
38.01718   16.49928 
18   40 
38.01714   16.4993 
18   40 
38.08276   16.44805 
18   40 
38.08279   16.44805 
18   40 
38.08276   16.44806 
18   40 
40.58199   12.21471 
18   40 
40.58203   12.21471 
18   40 
40.58199   12.21472 
Fit Mean:  49.22252  Size:  -4.574473  Code:  1 
Try Mean:  29.84158  Size:  0.1 
18   40 
29.84158   0.1 
18   40 
29.84158   0.1 
18   40 
29.84161   0.1 
18   40 
29.84158   0.100001 
18   40 
29.84162   0.101199 
18   40 
29.84165   0.101199 
18   40 
29.84162   0.1012 
18   40 
35.13115   10.12912 
18   40 
35.13118   10.12912 
18   40 
35.13115   10.12913 
18   40 
42.49404   20.70571 
18   40 
38.58699   15.09334 
18   40 
38.58703   15.09334 
18   40 
38.58699   15.09335 
18   40 
38.65547   14.99553 
18   40 
38.65551   14.99553 
18   40 
38.65547   14.99554 
18   40 
44.82443   2.226552 
18   40 
39.42081   13.41136 
18   40 
39.42085   13.41136 
18   40 
39.42081   13.41137 
Fit Mean:  46.76005  Size:  -2.22003  Code:  1 
Try Mean:  29.84158  Size:  0.01 
18   40 
29.84158   0.01 
18   40 
29.84158   0.01 
18   40 
29.84161   0.01 
18   40 
29.84158   0.010001 
18   40 
29.84159   0.01122741 
18   40 
29.84162   0.01122741 
18   40 
29.84159   0.01122841 
18   40 
34.1678   8.649239 
18   40 
34.16783   8.649239 
18   40 
34.1678   8.649248 
18   40 
44.63015   24.26215 
18   40 
38.52498   15.15143 
18   40 
38.52502   15.15143 
18   40 
38.52498   15.15145 
18   40 
38.6061   15.08811 
18   40 
38.60614   15.08811 
18   40 
38.6061   15.08812 
18   40 
41.6501   10.40965 
18   40 
41.65015   10.40965 
18   40 
41.6501   10.40966 
18   40 
46.50495   3.127787 
18   40 
42.13559   9.681466 
18   40 
42.13563   9.681466 
18   40 
42.13559   9.681476 
18   40 
44.67586   7.159997 
18   40 
44.67591   7.159997 
18   40 
44.67586   7.160004 
18   40 
44.51058   8.148422 
18   40 
44.51062   8.148422 
18   40 
44.51058   8.14843 
18   40 
45.88128   7.829922 
18   40 
45.88132   7.829922 
18   40 
45.88128   7.82993 
18   40 
49.88372   6.406517 
18   40 
49.88377   6.406517 
18   40 
49.88372   6.406523 
18   40 
52.70054   5.8792 
18   40 
52.70059   5.8792 
18   40 
52.70054   5.879206 
18   40 
56.43767   5.662536 
18   40 
56.43772   5.662536 
18   40 
56.43767   5.662542 
18   40 
64.0796   4.375527 
18   40 
59.70893   5.111609 
18   40 
59.70899   5.111609 
18   40 
59.70893   5.111614 
18   40 
64.18833   4.601016 
18   40 
64.1884   4.601016 
18   40 
64.18833   4.60102 
18   40 
65.4094   4.64738 
18   40 
65.40947   4.64738 
18   40 
65.4094   4.647384 
18   40 
70.46249   4.394868 
18   40 
70.46256   4.394868 
18   40 
70.46249   4.394872 
18   40 
77.02752   4.04604 
18   40 
77.0276   4.04604 
18   40 
77.02752   4.046044 
18   40 
81.5293   3.950597 
18   40 
81.52938   3.950597 
18   40 
81.5293   3.950601 
18   40 
89.43578   3.703699 
18   40 
89.43587   3.703699 
18   40 
89.43578   3.703703 
18   40 
95.37978   3.636997 
18   40 
95.37987   3.636997 
18   40 
95.37978   3.637001 
18   40 
106.1081   3.41211 
18   40 
106.1082   3.41211 
18   40 
106.1081   3.412113 
18   40 
107.795   3.429774 
18   40 
107.7952   3.429774 
18   40 
107.795   3.429777 
18   40 
117.0795   3.321474 
18   40 
117.0796   3.321474 
18   40 
117.0795   3.321478 
18   40 
128.907   3.196696 
18   40 
128.9072   3.196696 
18   40 
128.907   3.196699 
18   40 
136.9922   3.154726 
18   40 
136.9923   3.154726 
18   40 
136.9922   3.154729 
18   40 
151.4435   3.049353 
18   40 
151.4436   3.049353 
18   40 
151.4435   3.049356 
18   40 
157.6172   3.036487 
18   40 
157.6174   3.036487 
18   40 
157.6172   3.03649 
18   40 
173.3092   2.960984 
18   40 
173.3094   2.960984 
18   40 
173.3092   2.960987 
18   40 
183.8066   2.928659 
18   40 
183.8067   2.928659 
18   40 
183.8066   2.928662 
18   40 
197.1938   2.889507 
18   40 
197.194   2.889507 
18   40 
197.1938   2.88951 
18   40 
211.959   2.855813 
18   40 
211.9592   2.855813 
18   40 
211.959   2.855816 
18   40 
246.1838   2.757577 
18   40 
218.7312   2.836375 
18   40 
218.7314   2.836375 
18   40 
218.7312   2.836378 
18   40 
241.531   2.788207 
18   40 
241.5313   2.788207 
18   40 
241.531   2.78821 
18   40 
249.6097   2.781163 
18   40 
249.6099   2.781163 
18   40 
249.6097   2.781166 
18   40 
270.8815   2.746506 
18   40 
270.8818   2.746506 
18   40 
270.8815   2.746509 
18   40 
282.9599   2.732613 
18   40 
282.9601   2.732613 
18   40 
282.9599   2.732616 
18   40 
297.5559   2.717455 
18   40 
297.5562   2.717455 
18   40 
297.5559   2.717457 
18   40 
319.8312   2.691755 
18   40 
319.8315   2.691755 
18   40 
319.8312   2.691757 
18   40 
329.3055   2.687963 
18   40 
329.3058   2.687963 
18   40 
329.3055   2.687966 
18   40 
345.2379   2.673224 
18   40 
345.2383   2.673224 
18   40 
345.2379   2.673226 
18   40 
353.7511   2.666795 
18   40 
353.7514   2.666795 
18   40 
353.7511   2.666798 
18   40 
361.9134   2.662017 
18   40 
361.9137   2.662017 
18   40 
361.9134   2.66202 
Fit Mean:  361.9134  Size:  2.662017  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  361.9134  Size:  2.662017  Code:  1  Try Size:  0.01 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
18 40
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
Fallback to calculating off an estimate of just variance = mu + mu^2/size
Mu estimate= 29.84158  Size estimate = 24.33767 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 0
> print(nb_fit_mu);
[1] 0
> 
> print(m)
[1] 29.84158
> print(v)
[1] 66.43177
> print(D)
[1] 2.226148
> 
> print(deletion_propagation_coverage)
[1] 11
> 
> warnings()
> 
