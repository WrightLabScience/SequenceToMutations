
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | 3a+_BHI_c50_out/07_error_calibration/93.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | 3a+_BHI_c50_out/output/calibration/93.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.00296695 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 6 to 18.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  12.61538  Size:  10000 
6   18 
12.61538   10000 
6   18 
12.61538   10000 
6   18 
12.6154   10000 
6   18 
12.61538   10000.01 
6   18 
12.61646   10000 
6   18 
12.61648   10000 
6   18 
12.61646   10000.01 
6   18 
12.73407   10000 
6   18 
12.73408   10000 
6   18 
12.73407   10000.01 
6   18 
12.73572   10000 
6   18 
12.73573   10000 
6   18 
12.73572   10000.01 
6   18 
12.73574   10000 
6   18 
12.73576   10000 
6   18 
12.73574   10000.01 
6   18 
12.73574   10000 
6   18 
12.73702   10000 
6   18 
12.73447   10000 
6   18 
12.73574   10001 
6   18 
12.73574   9999 
6   18 
12.73575   10000 
6   18 
12.73702   10000 
6   18 
12.73448   10000 
6   18 
12.73575   10001 
6   18 
12.73575   9999 
Fit Mean:  12.73575  Size:  10000  Code:  2 
Try Mean:  12.61538  Size:  1000 
6   18 
12.61538   1000 
6   18 
12.61538   1000 
6   18 
12.6154   1000 
6   18 
12.61538   1000.001 
6   18 
12.61656   1000 
6   18 
12.61657   1000 
6   18 
12.61656   1000.001 
6   18 
12.74561   1000 
6   18 
12.74563   1000 
6   18 
12.74561   1000.001 
6   18 
12.74762   1000 
6   18 
12.74763   1000 
6   18 
12.74762   1000.001 
6   18 
12.74765   1000 
6   18 
12.74767   1000 
6   18 
12.74765   1000.001 
6   18 
12.74767   1000 
6   18 
12.74768   1000 
6   18 
12.74767   1000.001 
6   18 
12.74771   1000 
6   18 
12.74773   1000 
6   18 
12.74771   1000.001 
6   18 
12.74778   1000.001 
6   18 
12.74779   1000.001 
6   18 
12.74778   1000.002 
6   18 
12.74788   1000.003 
6   18 
12.7479   1000.003 
6   18 
12.74788   1000.004 
6   18 
12.74805   1000.008 
6   18 
12.74807   1000.008 
6   18 
12.74805   1000.009 
6   18 
12.74833   1000.022 
6   18 
12.74834   1000.022 
6   18 
12.74833   1000.023 
6   18 
12.74877   1000.06 
6   18 
12.74879   1000.06 
6   18 
12.74877   1000.061 
6   18 
12.7495   1000.159 
6   18 
12.74951   1000.159 
6   18 
12.7495   1000.16 
6   18 
12.75066   1000.42 
6   18 
12.75067   1000.42 
6   18 
12.75066   1000.421 
6   18 
12.75254   1001.106 
6   18 
12.75255   1001.106 
6   18 
12.75254   1001.107 
6   18 
12.75555   1002.899 
6   18 
12.75556   1002.899 
6   18 
12.75555   1002.9 
6   18 
12.76034   1007.566 
6   18 
12.76035   1007.566 
6   18 
12.76034   1007.567 
6   18 
12.76775   1019.579 
6   18 
12.76777   1019.579 
6   18 
12.76775   1019.58 
6   18 
12.77859   1049.715 
6   18 
12.7786   1049.715 
6   18 
12.77859   1049.716 
6   18 
12.79233   1121.486 
6   18 
12.79234   1121.486 
6   18 
12.79233   1121.487 
6   18 
12.80464   1279.508 
6   18 
12.80465   1279.508 
6   18 
12.80464   1279.51 
6   18 
12.80513   1600.344 
6   18 
12.80514   1600.344 
6   18 
12.80513   1600.345 
6   18 
12.78121   2173.396 
6   18 
12.78123   2173.396 
6   18 
12.78121   2173.398 
6   18 
12.74427   2923.413 
6   18 
12.74428   2923.413 
6   18 
12.74427   2923.416 
6   18 
12.72215   3600.798 
6   18 
12.72217   3600.798 
6   18 
12.72215   3600.802 
6   18 
12.7129   4307.417 
6   18 
12.71291   4307.417 
6   18 
12.7129   4307.422 
6   18 
12.71188   5503.299 
6   18 
12.7119   5503.299 
6   18 
12.71188   5503.304 
6   18 
12.72168   7348.133 
6   18 
12.72169   7348.133 
6   18 
12.72168   7348.141 
6   18 
12.73477   9691.226 
6   18 
12.73479   9691.226 
6   18 
12.73477   9691.235 
6   18 
12.74266   12260.83 
6   18 
12.74268   12260.83 
6   18 
12.74266   12260.84 
6   18 
12.74538   15580.2 
6   18 
12.74539   15580.2 
6   18 
12.74538   15580.21 
6   18 
12.74315   20571.89 
6   18 
12.74316   20571.89 
6   18 
12.74315   20571.91 
6   18 
12.73755   27481.1 
6   18 
12.73756   27481.1 
6   18 
12.73755   27481.12 
6   18 
12.73265   35837.51 
6   18 
12.73266   35837.51 
6   18 
12.73265   35837.55 
6   18 
12.73023   45952.62 
6   18 
12.73025   45952.62 
6   18 
12.73023   45952.66 
6   18 
12.73022   60082.88 
6   18 
12.73023   60082.88 
6   18 
12.73022   60082.94 
6   18 
12.73221   79943.37 
6   18 
12.73222   79943.37 
6   18 
12.73221   79943.45 
6   18 
12.73465   105579.3 
6   18 
12.73466   105579.3 
6   18 
12.73465   105579.4 
6   18 
12.73618   136724.5 
6   18 
12.73619   136724.5 
6   18 
12.73618   136724.7 
6   18 
12.73659   178925.4 
6   18 
12.7366   178925.4 
6   18 
12.73659   178925.6 
6   18 
12.73594   238121.2 
6   18 
12.73595   238121.2 
6   18 
12.73594   238121.5 
6   18 
12.7348   314780.1 
6   18 
12.73481   314780.1 
6   18 
12.7348   314780.4 
6   18 
12.73399   395623.7 
6   18 
12.73401   395623.7 
6   18 
12.73399   395624.1 
6   18 
12.73257   683043.1 
6   18 
12.73258   683043.1 
6   18 
12.73257   683043.7 
6   18 
12.73286   855170.3 
6   18 
12.73288   855170.3 
6   18 
12.73286   855171.2 
6   18 
12.73375   992919.9 
6   18 
12.73376   992919.9 
6   18 
12.73375   992920.9 
6   18 
12.73417   1092981 
6   18 
12.73418   1092981 
6   18 
12.73417   1092982 
6   18 
12.73446   1279207 
6   18 
12.73447   1279207 
6   18 
12.73446   1279209 
6   18 
12.73445   1275592 
6   18 
12.73446   1278846 
6   18 
12.73446   1279171 
6   18 
12.73446   1279204 
6   18 
12.73446   1279207 
6   18 
12.73573   1279207 
6   18 
12.73319   1279207 
6   18 
12.73446   1279335 
6   18 
12.73446   1279079 
6   18 
12.7345   1340004 
6   18 
12.73577   1340004 
6   18 
12.73323   1340004 
6   18 
12.7345   1340138 
6   18 
12.7345   1339870 
6   18 
12.73466   1905609 
6   18 
12.73594   1905609 
6   18 
12.73339   1905609 
6   18 
12.73466   1905800 
6   18 
12.73466   1905419 
6   18 
12.73464   2444945 
6   18 
12.73591   2444945 
6   18 
12.73336   2444945 
6   18 
12.73464   2445189 
6   18 
12.73464   2444700 
6   18 
12.73452   3339138 
6   18 
12.73579   3339138 
6   18 
12.73324   3339138 
6   18 
12.73452   3339472 
6   18 
12.73452   3338804 
6   18 
12.73441   4237176 
6   18 
12.73569   4237176 
6   18 
12.73314   4237176 
6   18 
12.73441   4237600 
6   18 
12.73441   4236752 
6   18 
12.73438   4800394 
6   18 
12.73566   4800394 
6   18 
12.73311   4800394 
6   18 
12.73438   4800874 
6   18 
12.73438   4799914 
6   18 
12.73438   5222859 
6   18 
12.73565   5222859 
6   18 
12.7331   5222859 
6   18 
12.73438   5223381 
6   18 
12.73438   5222337 
6   18 
12.73437   5667479 
6   18 
12.73565   5667479 
6   18 
12.7331   5667479 
6   18 
12.73437   5668046 
6   18 
12.73437   5666913 
6   18 
12.73439   6667559 
6   18 
12.73566   6667559 
6   18 
12.73311   6667559 
6   18 
12.73439   6668226 
6   18 
12.73439   6666892 
6   18 
12.7344   7667638 
6   18 
12.73568   7667638 
6   18 
12.73313   7667638 
6   18 
12.7344   7668405 
6   18 
12.7344   7666872 
6   18 
12.73442   8667718 
6   18 
12.73569   8667718 
6   18 
12.73314   8667718 
6   18 
12.73442   8668585 
6   18 
12.73442   8666851 
6   18 
12.73443   9667798 
6   18 
12.7357   9667798 
6   18 
12.73316   9667798 
6   18 
12.73443   9668764 
6   18 
12.73443   9666831 
Fit Mean:  12.73443  Size:  9667798  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  12.73443  Size:  9667798  Code:  1  Try Size:  1000 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
6 18
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
9667798   12.73443 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 9667798
> print(nb_fit_mu);
[1] 12.73443
> 
> print(m)
[1] 28.20879
> print(v)
[1] 230.767
> print(D)
[1] 8.180678
> 
> print(deletion_propagation_coverage)
[1] 4
> 
> warnings()
> 
