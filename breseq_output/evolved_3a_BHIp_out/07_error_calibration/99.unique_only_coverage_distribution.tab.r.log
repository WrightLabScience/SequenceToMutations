
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | 3a+_BHI_c50_out/07_error_calibration/99.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | 3a+_BHI_c50_out/output/calibration/99.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.00331862 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 11 to 30.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  19.50331  Size:  10000 
11   30 
19.50331   10000 
11   30 
19.50331   10000 
11   30 
19.50333   10000 
11   30 
19.50331   10000.01 
11   30 
19.51498   10000 
11   30 
19.515   10000 
11   30 
19.51498   10000.01 
11   30 
25.97639   10000 
11   30 
25.97641   10000 
11   30 
25.97639   10000.01 
11   30 
24.05077   10000 
11   30 
24.05079   10000 
11   30 
24.05077   10000.01 
11   30 
23.98391   10000 
11   30 
23.98394   10000 
11   30 
23.98391   10000.01 
11   30 
23.99071   10000 
11   30 
23.99074   10000 
11   30 
23.99071   10000.01 
11   30 
23.9907   10000 
11   30 
23.99311   10000 
11   30 
23.98831   10000 
11   30 
23.99071   10001 
11   30 
23.99071   9999 
11   30 
23.99071   10000 
11   30 
23.99311   10000 
11   30 
23.98831   10000 
11   30 
23.99071   10001 
11   30 
23.99071   9999 
Fit Mean:  23.99071  Size:  10000  Code:  2 
Try Mean:  19.50331  Size:  1000 
11   30 
19.50331   1000 
11   30 
19.50331   1000 
11   30 
19.50333   1000 
11   30 
19.50331   1000.001 
11   30 
19.51483   1000 
11   30 
19.51485   1000 
11   30 
19.51483   1000.001 
11   30 
25.85914   1000 
11   30 
25.85917   1000 
11   30 
25.85914   1000.001 
11   30 
24.07737   1000 
11   30 
24.07739   1000 
11   30 
24.07737   1000.001 
11   30 
24.0057   1000 
11   30 
24.00573   1000 
11   30 
24.0057   1000.001 
11   30 
24.01255   1000 
11   30 
24.01257   1000 
11   30 
24.01255   1000.001 
11   30 
24.01253   1000 
11   30 
24.01256   1000 
11   30 
24.01253   1000.001 
Fit Mean:  24.01253  Size:  1000  Code:  2 
Try Mean:  19.50331  Size:  100 
11   30 
19.50331   100 
11   30 
19.50331   100 
11   30 
19.50333   100 
11   30 
19.50331   100.0001 
11   30 
19.51356   99.99998 
11   30 
19.51358   99.99998 
11   30 
19.51356   100.0001 
11   30 
25.07267   100.019 
11   30 
25.0727   100.019 
11   30 
25.07267   100.0191 
11   30 
24.33123   100.016 
11   30 
24.33125   100.016 
11   30 
24.33123   100.0161 
11   30 
24.25109   100.0204 
11   30 
24.25112   100.0204 
11   30 
24.25109   100.0205 
11   30 
24.25465   100.0248 
11   30 
24.25468   100.0248 
11   30 
24.25465   100.0249 
11   30 
24.25991   100.0427 
11   30 
24.25993   100.0427 
11   30 
24.25991   100.0428 
11   30 
24.26866   100.1035 
11   30 
24.26868   100.1035 
11   30 
24.26866   100.1036 
11   30 
24.2823   100.2793 
11   30 
24.28232   100.2793 
11   30 
24.2823   100.2794 
11   30 
24.30358   100.7694 
11   30 
24.30361   100.7694 
11   30 
24.30358   100.7695 
11   30 
24.33507   102.0738 
11   30 
24.33509   102.0738 
11   30 
24.33507   102.0739 
11   30 
24.37736   105.4168 
11   30 
24.37739   105.4168 
11   30 
24.37736   105.4169 
11   30 
24.4219   113.5521 
11   30 
24.42192   113.5521 
11   30 
24.4219   113.5522 
11   30 
24.4392   132.5512 
11   30 
24.43922   132.5512 
11   30 
24.4392   132.5513 
11   30 
24.36227   176.3522 
11   30 
24.36229   176.3522 
11   30 
24.36227   176.3523 
11   30 
24.13509   258.9334 
11   30 
24.13512   258.9334 
11   30 
24.13509   258.9336 
11   30 
23.98319   327.1344 
11   30 
23.98322   327.1344 
11   30 
23.98319   327.1348 
11   30 
23.94846   367.9321 
11   30 
23.94849   367.9321 
11   30 
23.94846   367.9324 
11   30 
23.93341   471.6343 
11   30 
23.93343   471.6343 
11   30 
23.93341   471.6348 
11   30 
23.96926   617.4812 
11   30 
23.96928   617.4812 
11   30 
23.96926   617.4818 
11   30 
24.01445   806.3875 
11   30 
24.01447   806.3875 
11   30 
24.01445   806.3883 
11   30 
24.03399   1026.858 
11   30 
24.03401   1026.858 
11   30 
24.03399   1026.859 
11   30 
24.03081   1344.234 
11   30 
24.03083   1344.234 
11   30 
24.03081   1344.235 
11   30 
24.01093   1795.814 
11   30 
24.01095   1795.814 
11   30 
24.01093   1795.816 
11   30 
23.99119   2370.179 
11   30 
23.99122   2370.179 
11   30 
23.99119   2370.181 
11   30 
23.98115   3089.497 
11   30 
23.98117   3089.497 
11   30 
23.98115   3089.5 
11   30 
23.98082   4063.973 
11   30 
23.98084   4063.973 
11   30 
23.98082   4063.977 
11   30 
23.98655   5383.306 
11   30 
23.98657   5383.306 
11   30 
23.98655   5383.312 
11   30 
23.99229   7100.733 
11   30 
23.99232   7100.733 
11   30 
23.99229   7100.74 
11   30 
23.99464   9348.661 
11   30 
23.99466   9348.661 
11   30 
23.99464   9348.67 
11   30 
23.99348   12373.93 
11   30 
23.9935   12373.93 
11   30 
23.99348   12373.94 
11   30 
23.99055   16414.41 
11   30 
23.99058   16414.41 
11   30 
23.99055   16414.42 
11   30 
23.98803   21711.18 
11   30 
23.98805   21711.18 
11   30 
23.98803   21711.2 
11   30 
23.98697   28680.36 
11   30 
23.987   28680.36 
11   30 
23.98697   28680.39 
11   30 
23.98729   37978.49 
11   30 
23.98732   37978.49 
11   30 
23.98729   37978.53 
11   30 
23.98823   50313.93 
11   30 
23.98825   50313.93 
11   30 
23.98823   50313.98 
11   30 
23.98898   66541.22 
11   30 
23.989   66541.22 
11   30 
23.98898   66541.29 
11   30 
23.98918   88039.58 
11   30 
23.98921   88039.58 
11   30 
23.98918   88039.67 
11   30 
23.98892   116881.2 
11   30 
23.98894   116881.2 
11   30 
23.98892   116881.4 
11   30 
23.98849   154674.3 
11   30 
23.98851   154674.3 
11   30 
23.98849   154674.5 
11   30 
23.98817   204539.5 
11   30 
23.9882   204539.5 
11   30 
23.98817   204539.7 
11   30 
23.98808   272745.3 
11   30 
23.9881   272745.3 
11   30 
23.98808   272745.6 
11   30 
23.98817   360038.4 
11   30 
23.98819   360038.4 
11   30 
23.98817   360038.8 
11   30 
23.98831   461922.5 
11   30 
23.98833   461922.5 
11   30 
23.98831   461923 
11   30 
23.98838   563806.7 
11   30 
23.9884   563806.7 
11   30 
23.98838   563807.3 
11   30 
23.98839   665690.8 
11   30 
23.98841   665690.8 
11   30 
23.98839   665691.5 
11   30 
23.98839   767575 
11   30 
23.98842   767575 
11   30 
23.98839   767575.8 
11   30 
23.98837   869459.1 
11   30 
23.98839   869459.1 
11   30 
23.98837   869460 
Fit Mean:  23.98837  Size:  869459.1  Code:  5 
Try Mean:  19.50331  Size:  10 
11   30 
19.50331   10 
11   30 
19.50331   10 
11   30 
19.50333   10 
11   30 
19.50331   10.00001 
11   30 
19.50837   10.00018 
11   30 
19.50839   10.00018 
11   30 
19.50837   10.00019 
11   30 
25.10504   11.78046 
11   30 
25.10506   11.78046 
11   30 
25.10504   11.78047 
11   30 
26.87921   12.94953 
11   30 
26.87924   12.94953 
11   30 
26.87921   12.94954 
11   30 
27.26976   13.43102 
11   30 
27.26979   13.43102 
11   30 
27.26976   13.43103 
11   30 
27.32928   13.81778 
11   30 
27.3293   13.81778 
11   30 
27.32928   13.8178 
11   30 
27.18775   15.92069 
11   30 
27.18778   15.92069 
11   30 
27.18775   15.9207 
11   30 
26.02088   22.80207 
11   30 
26.02091   22.80207 
11   30 
26.02088   22.80209 
11   30 
16.1938   78.76813 
11   30 
25.03817   28.39867 
11   30 
25.0382   28.39867 
11   30 
25.03817   28.3987 
11   30 
24.13362   35.75394 
11   30 
24.13365   35.75394 
11   30 
24.13362   35.75397 
11   30 
24.47507   35.58383 
11   30 
24.4751   35.58383 
11   30 
24.47507   35.58387 
11   30 
24.73085   40.61613 
11   30 
24.73088   40.61613 
11   30 
24.73085   40.61617 
11   30 
24.7034   50.69249 
11   30 
24.70343   50.69249 
11   30 
24.7034   50.69254 
11   30 
24.3269   71.44303 
11   30 
24.32693   71.44303 
11   30 
24.3269   71.4431 
11   30 
24.0987   94.26089 
11   30 
24.09873   94.26089 
11   30 
24.0987   94.26098 
11   30 
24.08774   120.3482 
11   30 
24.08776   120.3482 
11   30 
24.08774   120.3483 
11   30 
24.12275   158.6529 
11   30 
24.12278   158.6529 
11   30 
24.12275   158.6531 
11   30 
24.08675   208.3334 
11   30 
24.08677   208.3334 
11   30 
24.08675   208.3336 
11   30 
24.05721   275.8585 
11   30 
24.05723   275.8585 
11   30 
24.05721   275.8588 
11   30 
24.04188   363.6907 
11   30 
24.04191   363.6907 
11   30 
24.04188   363.6911 
11   30 
24.02798   480.3415 
11   30 
24.028   480.3415 
11   30 
24.02798   480.342 
11   30 
24.01888   634.4197 
11   30 
24.0189   634.4197 
11   30 
24.01888   634.4203 
11   30 
24.01098   838.4818 
11   30 
24.011   838.4818 
11   30 
24.01098   838.4826 
11   30 
24.00581   1108.601 
11   30 
24.00584   1108.601 
11   30 
24.00581   1108.603 
11   30 
24.0012   1466.361 
11   30 
24.00123   1466.361 
11   30 
24.0012   1466.363 
11   30 
23.99835   1940.166 
11   30 
23.99838   1940.166 
11   30 
23.99835   1940.168 
11   30 
23.9956   2567.797 
11   30 
23.99562   2567.797 
11   30 
23.9956   2567.8 
11   30 
23.9941   3399.124 
11   30 
23.99412   3399.124 
11   30 
23.9941   3399.127 
11   30 
23.99239   4500.435 
11   30 
23.99242   4500.435 
11   30 
23.99239   4500.439 
11   30 
23.99168   5959.255 
11   30 
23.9917   5959.255 
11   30 
23.99168   5959.261 
11   30 
23.99056   7891.895 
11   30 
23.99058   7891.895 
11   30 
23.99056   7891.903 
11   30 
23.9903   10452.01 
11   30 
23.99033   10452.01 
11   30 
23.9903   10452.02 
11   30 
23.9895   13843.49 
11   30 
23.98953   13843.49 
11   30 
23.9895   13843.51 
11   30 
23.98953   18336.88 
11   30 
23.98955   18336.88 
11   30 
23.98953   18336.9 
11   30 
23.9889   24287.2 
11   30 
23.98892   24287.2 
11   30 
23.9889   24287.23 
11   30 
23.98909   32176.57 
11   30 
23.98911   32176.57 
11   30 
23.98909   32176.6 
11   30 
23.98855   42620.13 
11   30 
23.98857   42620.13 
11   30 
23.98855   42620.17 
11   30 
23.98885   56479.38 
11   30 
23.98887   56479.38 
11   30 
23.98885   56479.43 
11   30 
23.98835   74810.12 
11   30 
23.98837   74810.12 
11   30 
23.98835   74810.2 
11   30 
23.98867   96727.67 
11   30 
23.98869   96727.67 
11   30 
23.98867   96727.77 
11   30 
23.98838   118645.2 
11   30 
23.98841   118645.2 
11   30 
23.98838   118645.3 
11   30 
23.98848   140562.8 
11   30 
23.9885   140562.8 
11   30 
23.98848   140562.9 
Fit Mean:  23.98848  Size:  140562.8  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  23.98848  Size:  140562.8  Code:  1  Try Size:  10 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
11 30
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
140562.8   23.98848 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 140562.8
> print(nb_fit_mu);
[1] 23.98848
> 
> print(m)
[1] 19.50331
> print(v)
[1] 56.94499
> print(D)
[1] 2.91976
> 
> print(deletion_propagation_coverage)
[1] 12
> 
> warnings()
> 
