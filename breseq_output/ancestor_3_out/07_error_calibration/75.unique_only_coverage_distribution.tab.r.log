
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | p3_out/07_error_calibration/75.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | p3_out/output/calibration/75.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.00216982 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 17 to 53.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  34.24561  Size:  10000 
17   53 
34.24561   10000 
17   53 
34.24561   10000 
17   53 
34.24565   10000 
17   53 
34.24561   10000.01 
17   53 
34.24995   10000 
17   53 
34.24999   10000 
17   53 
34.24995   10000.01 
17   53 
37.23832   10000 
17   53 
37.23836   10000 
17   53 
37.23832   10000.01 
17   53 
37.01998   10000 
17   53 
37.02002   10000 
17   53 
37.01998   10000.01 
17   53 
37.01667   10000 
17   53 
37.01671   10000 
17   53 
37.01667   10000.01 
17   53 
37.0167   10000 
17   53 
37.01673   10000 
17   53 
37.0167   10000.01 
Fit Mean:  37.0167  Size:  10000  Code:  2 
Try Mean:  34.24561  Size:  1000 
17   53 
34.24561   1000 
17   53 
34.24561   1000 
17   53 
34.24565   1000 
17   53 
34.24561   1000.001 
17   53 
34.24982   1000 
17   53 
34.24986   1000 
17   53 
34.24982   1000.001 
17   53 
37.24286   1000 
17   53 
37.24289   1000 
17   53 
37.24286   1000.001 
17   53 
37.03482   1000 
17   53 
37.03486   1000 
17   53 
37.03482   1000.001 
17   53 
37.03131   1000.001 
17   53 
37.03135   1000.001 
17   53 
37.03131   1000.002 
17   53 
37.03133   1000.001 
17   53 
37.03136   1000.001 
17   53 
37.03133   1000.002 
Fit Mean:  37.03133  Size:  1000.001  Code:  2 
Try Mean:  34.24561  Size:  100 
17   53 
34.24561   100 
17   53 
34.24561   100 
17   53 
34.24565   100 
17   53 
34.24561   100.0001 
17   53 
34.24879   100 
17   53 
34.24882   100 
17   53 
34.24879   100.0001 
17   53 
37.24803   100.038 
17   53 
37.24807   100.038 
17   53 
37.24803   100.0381 
17   53 
37.14608   100.0536 
17   53 
37.14611   100.0536 
17   53 
37.14608   100.0537 
17   53 
37.13941   100.0726 
17   53 
37.13944   100.0726 
17   53 
37.13941   100.0727 
17   53 
37.0924   100.3509 
17   53 
37.09244   100.3509 
17   53 
37.0924   100.351 
17   53 
37.03955   100.9717 
17   53 
37.03959   100.9717 
17   53 
37.03955   100.9718 
17   53 
36.94526   102.9569 
17   53 
36.9453   102.9569 
17   53 
36.94526   102.957 
17   53 
36.82043   107.7834 
17   53 
36.82047   107.7834 
17   53 
36.82043   107.7835 
17   53 
36.67698   119.2139 
17   53 
36.67702   119.2139 
17   53 
36.67698   119.2141 
17   53 
36.58968   143.2122 
17   53 
36.58972   143.2122 
17   53 
36.58968   143.2124 
17   53 
36.68358   190.2666 
17   53 
36.68362   190.2666 
17   53 
36.68358   190.2668 
17   53 
36.96892   260.7129 
17   53 
36.96895   260.7129 
17   53 
36.96892   260.7132 
17   53 
37.15501   330.2431 
17   53 
37.15505   330.2431 
17   53 
37.15501   330.2434 
17   53 
37.21634   406.2553 
17   53 
37.21638   406.2553 
17   53 
37.21634   406.2557 
17   53 
37.18767   532.9733 
17   53 
37.18771   532.9733 
17   53 
37.18767   532.9738 
17   53 
37.08261   716.076 
17   53 
37.08264   716.076 
17   53 
37.08261   716.0767 
17   53 
36.99495   932.2927 
17   53 
36.99499   932.2927 
17   53 
36.99495   932.2936 
17   53 
36.95835   1190.229 
17   53 
36.95839   1190.229 
17   53 
36.95835   1190.23 
17   53 
36.96486   1561.88 
17   53 
36.9649   1561.88 
17   53 
36.96486   1561.882 
17   53 
36.99982   2075.255 
17   53 
36.99986   2075.255 
17   53 
36.99982   2075.257 
17   53 
37.0309   2722.69 
17   53 
37.03094   2722.69 
17   53 
37.0309   2722.693 
17   53 
37.04352   3553.115 
17   53 
37.04356   3553.115 
17   53 
37.04352   3553.119 
17   53 
37.03845   4694.495 
17   53 
37.03849   4694.495 
17   53 
37.03845   4694.5 
17   53 
37.02379   6233.847 
17   53 
37.02383   6233.847 
17   53 
37.02379   6233.853 
17   53 
37.01108   8221.919 
17   53 
37.01112   8221.919 
17   53 
37.01108   8221.928 
17   53 
37.00584   10817.85 
17   53 
37.00587   10817.85 
17   53 
37.00584   10817.87 
17   53 
37.00774   14311.27 
17   53 
37.00777   14311.27 
17   53 
37.00774   14311.29 
17   53 
37.01315   18969.67 
17   53 
37.01319   18969.67 
17   53 
37.01315   18969.69 
17   53 
37.01774   25068.03 
17   53 
37.01778   25068.03 
17   53 
37.01774   25068.05 
17   53 
37.01939   33110.59 
17   53 
37.01943   33110.59 
17   53 
37.01939   33110.62 
17   53 
37.01829   43850.21 
17   53 
37.01833   43850.21 
17   53 
37.01829   43850.25 
17   53 
37.01599   58112.85 
17   53 
37.01603   58112.85 
17   53 
37.01599   58112.9 
17   53 
37.01413   76899.43 
17   53 
37.01416   76899.43 
17   53 
37.01413   76899.51 
17   53 
37.01348   101720.5 
17   53 
37.01352   101720.5 
17   53 
37.01348   101720.6 
17   53 
37.01393   134797.7 
17   53 
37.01397   134797.7 
17   53 
37.01393   134797.9 
17   53 
37.01481   178513.2 
17   53 
37.01485   178513.2 
17   53 
37.01481   178513.4 
17   53 
37.0155   236449.1 
17   53 
37.01554   236449.1 
17   53 
37.0155   236449.4 
17   53 
37.0157   313342 
17   53 
37.01574   313342 
17   53 
37.0157   313342.3 
17   53 
37.01548   415355.4 
17   53 
37.01552   415355.4 
17   53 
37.01548   415355.9 
17   53 
37.01519   521056.7 
17   53 
37.01522   521056.7 
17   53 
37.01519   521057.3 
17   53 
37.015   626758 
17   53 
37.01504   626758 
17   53 
37.015   626758.6 
17   53 
37.01492   732459.3 
17   53 
37.01495   732459.3 
17   53 
37.01492   732460 
17   53 
37.0149   838160.6 
17   53 
37.01494   838160.6 
17   53 
37.0149   838161.4 
17   53 
37.01491   943861.9 
17   53 
37.01495   943861.9 
17   53 
37.01491   943862.8 
Fit Mean:  37.01491  Size:  943861.9  Code:  5 
Try Mean:  34.24561  Size:  10 
17   53 
34.24561   10 
17   53 
34.24561   10 
17   53 
34.24565   10 
17   53 
34.24561   10.00001 
17   53 
34.24648   10.00034 
17   53 
34.24652   10.00034 
17   53 
34.24648   10.00035 
17   53 
39.79512   15.63289 
17   53 
39.79516   15.63289 
17   53 
39.79512   15.6329 
17   53 
38.46222   15.67325 
17   53 
38.46226   15.67325 
17   53 
38.46222   15.67326 
17   53 
37.27392   18.0867 
17   53 
37.27396   18.0867 
17   53 
37.27392   18.08672 
17   53 
36.28905   24.29284 
17   53 
36.28908   24.29284 
17   53 
36.28905   24.29287 
17   53 
36.63627   33.2471 
17   53 
36.6363   33.2471 
17   53 
36.63627   33.24713 
17   53 
37.66325   53.25111 
17   53 
37.66329   53.25111 
17   53 
37.66325   53.25116 
17   53 
37.18668   72.78453 
17   53 
37.18672   72.78453 
17   53 
37.18668   72.7846 
17   53 
37.05587   103.341 
17   53 
37.0559   103.341 
17   53 
37.05587   103.3411 
17   53 
37.13803   139.4391 
17   53 
37.13807   139.4391 
17   53 
37.13803   139.4393 
17   53 
37.03555   188.6721 
17   53 
37.03559   188.6721 
17   53 
37.03555   188.6723 
17   53 
37.11316   252.289 
17   53 
37.11319   252.289 
17   53 
37.11316   252.2892 
17   53 
37.00593   337.5178 
17   53 
37.00597   337.5178 
17   53 
37.00593   337.5182 
17   53 
37.079   449.6608 
17   53 
37.07904   449.6608 
17   53 
37.079   449.6613 
17   53 
37.01881   597.1767 
17   53 
37.01885   597.1767 
17   53 
37.01881   597.1773 
17   53 
37.03961   791.2388 
17   53 
37.03964   791.2388 
17   53 
37.03961   791.2396 
17   53 
37.02357   1047.29 
17   53 
37.02361   1047.29 
17   53 
37.02357   1047.291 
17   53 
37.02662   1386.269 
17   53 
37.02665   1386.269 
17   53 
37.02662   1386.271 
17   53 
37.02103   1834.738 
17   53 
37.02107   1834.738 
17   53 
37.02103   1834.74 
17   53 
37.02114   2428.767 
17   53 
37.02118   2428.767 
17   53 
37.02114   2428.769 
17   53 
37.0187   3215.362 
17   53 
37.01874   3215.362 
17   53 
37.0187   3215.365 
17   53 
37.01838   4257.328 
17   53 
37.01841   4257.328 
17   53 
37.01838   4257.333 
17   53 
37.01719   5637.46 
17   53 
37.01723   5637.46 
17   53 
37.01719   5637.465 
17   53 
37.01689   7465.707 
17   53 
37.01693   7465.707 
17   53 
37.01689   7465.714 
17   53 
37.01628   9887.524 
17   53 
37.01632   9887.524 
17   53 
37.01628   9887.534 
17   53 
37.01607   13095.78 
17   53 
37.0161   13095.78 
17   53 
37.01607   13095.8 
17   53 
37.01574   17345.61 
17   53 
37.01578   17345.61 
17   53 
37.01574   17345.63 
17   53 
37.01561   22975.33 
17   53 
37.01564   22975.33 
17   53 
37.01561   22975.36 
17   53 
37.01543   30434.34 
17   53 
37.01547   30434.34 
17   53 
37.01543   30434.37 
17   53 
37.01535   40312.49 
17   53 
37.01539   40312.49 
17   53 
37.01535   40312.53 
17   53 
37.01525   53399.09 
17   53 
37.01529   53399.09 
17   53 
37.01525   53399.14 
17   53 
37.0152   70736.68 
17   53 
37.01524   70736.68 
17   53 
37.0152   70736.75 
17   53 
37.01515   93714.98 
17   53 
37.01519   93714.98 
17   53 
37.01515   93715.07 
17   53 
37.01512   124134.1 
17   53 
37.01516   124134.1 
17   53 
37.01512   124134.2 
17   53 
37.01509   159809.9 
17   53 
37.01513   159809.9 
17   53 
37.01509   159810.1 
17   53 
37.01508   195485.7 
17   53 
37.01512   195485.7 
17   53 
37.01508   195485.9 
17   53 
37.01507   231161.5 
17   53 
37.01511   231161.5 
17   53 
37.01507   231161.7 
Fit Mean:  37.01507  Size:  231161.5  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  37.01507  Size:  231161.5  Code:  1  Try Size:  10 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
17 53
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
231161.5   37.01507 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 231161.5
> print(nb_fit_mu);
[1] 37.01507
> 
> print(m)
[1] 35.94595
> print(v)
[1] 95.61663
> print(D)
[1] 2.660011
> 
> print(deletion_propagation_coverage)
[1] 21
> 
> warnings()
> 
