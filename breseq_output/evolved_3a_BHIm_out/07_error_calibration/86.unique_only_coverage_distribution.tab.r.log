
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | 3a-_BHI_c50_out/07_error_calibration/86.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | 3a-_BHI_c50_out/output/calibration/86.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.00267261 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 12 to 36.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  22.78621  Size:  10000 
12   36 
22.78621   10000 
12   36 
22.78621   10000 
12   36 
22.78623   10000 
12   36 
22.78621   10000.01 
12   36 
22.788   10000 
12   36 
22.78802   10000 
12   36 
22.788   10000.01 
12   36 
23.43414   10000 
12   36 
23.43416   10000 
12   36 
23.43414   10000.01 
12   36 
23.4471   10000 
12   36 
23.44713   10000 
12   36 
23.4471   10000.01 
12   36 
23.44744   10000 
12   36 
23.44747   10000 
12   36 
23.44744   10000.01 
12   36 
23.44744   10000 
12   36 
23.44747   10000 
12   36 
23.44744   10000.01 
Fit Mean:  23.44744  Size:  10000  Code:  2 
Try Mean:  22.78621  Size:  1000 
12   36 
22.78621   1000 
12   36 
22.78621   1000 
12   36 
22.78623   1000 
12   36 
22.78621   1000.001 
12   36 
22.78798   1000 
12   36 
22.788   1000 
12   36 
22.78798   1000.001 
12   36 
23.44142   1000 
12   36 
23.44144   1000 
12   36 
23.44142   1000.001 
12   36 
23.4554   1000 
12   36 
23.45542   1000 
12   36 
23.4554   1000.001 
12   36 
23.45578   1000 
12   36 
23.45581   1000 
12   36 
23.45578   1000.001 
12   36 
23.45578   1000 
12   36 
23.45581   1000 
12   36 
23.45578   1000.001 
Fit Mean:  23.45578  Size:  1000  Code:  2 
Try Mean:  22.78621  Size:  100 
12   36 
22.78621   100 
12   36 
22.78621   100 
12   36 
22.78623   100 
12   36 
22.78621   100.0001 
12   36 
22.78784   100 
12   36 
22.78786   100 
12   36 
22.78784   100.0001 
12   36 
23.51832   100.006 
12   36 
23.51834   100.006 
12   36 
23.51832   100.0061 
12   36 
23.54318   100.0088 
12   36 
23.54321   100.0088 
12   36 
23.54318   100.0089 
12   36 
23.5445   100.0117 
12   36 
23.54453   100.0117 
12   36 
23.5445   100.0118 
12   36 
23.5502   100.038 
12   36 
23.55022   100.038 
12   36 
23.5502   100.0381 
12   36 
23.55714   100.1018 
12   36 
23.55717   100.1018 
12   36 
23.55714   100.1019 
12   36 
23.56957   100.3054 
12   36 
23.56959   100.3054 
12   36 
23.56957   100.3055 
12   36 
23.58825   100.841 
12   36 
23.58828   100.841 
12   36 
23.58825   100.8411 
12   36 
23.61687   102.2736 
12   36 
23.61689   102.2736 
12   36 
23.61687   102.2737 
12   36 
23.65579   105.85 
12   36 
23.65582   105.85 
12   36 
23.65579   105.8501 
12   36 
23.6982   114.2426 
12   36 
23.69822   114.2426 
12   36 
23.6982   114.2427 
12   36 
23.71939   132.4319 
12   36 
23.71942   132.4319 
12   36 
23.71939   132.432 
12   36 
23.67238   169.2408 
12   36 
23.6724   169.2408 
12   36 
23.67238   169.241 
12   36 
23.53867   228.4623 
12   36 
23.5387   228.4623 
12   36 
23.53867   228.4625 
12   36 
23.43856   283.7934 
12   36 
23.43859   283.7934 
12   36 
23.43856   283.7937 
12   36 
23.40523   326.9367 
12   36 
23.40525   326.9367 
12   36 
23.40523   326.9371 
12   36 
23.3946   403.6845 
12   36 
23.39462   403.6845 
12   36 
23.3946   403.6849 
12   36 
23.41875   522.6636 
12   36 
23.41877   522.6636 
12   36 
23.41875   522.6641 
12   36 
23.45479   675.6589 
12   36 
23.45482   675.6589 
12   36 
23.45479   675.6596 
12   36 
23.47445   847.1605 
12   36 
23.47447   847.1605 
12   36 
23.47445   847.1613 
12   36 
23.47801   1078.221 
12   36 
23.47804   1078.221 
12   36 
23.47801   1078.222 
12   36 
23.46737   1418.48 
12   36 
23.46739   1418.48 
12   36 
23.46737   1418.482 
12   36 
23.45165   1866.869 
12   36 
23.45167   1866.869 
12   36 
23.45165   1866.871 
12   36 
23.44118   2411.222 
12   36 
23.44121   2411.222 
12   36 
23.44118   2411.225 
12   36 
23.43793   3122.351 
12   36 
23.43795   3122.351 
12   36 
23.43793   3122.354 
12   36 
23.44085   4111.516 
12   36 
23.44087   4111.516 
12   36 
23.44085   4111.52 
12   36 
23.44636   5425.487 
12   36 
23.44638   5425.487 
12   36 
23.44636   5425.492 
12   36 
23.45036   7102.194 
12   36 
23.45039   7102.194 
12   36 
23.45036   7102.202 
12   36 
23.45145   9312.625 
12   36 
23.45147   9312.625 
12   36 
23.45145   9312.635 
12   36 
23.44998   12322.04 
12   36 
23.45001   12322.04 
12   36 
23.44998   12322.05 
12   36 
23.44748   16321.65 
12   36 
23.4475   16321.65 
12   36 
23.44748   16321.66 
12   36 
23.44556   21506.14 
12   36 
23.44558   21506.14 
12   36 
23.44556   21506.17 
12   36 
23.4449   28333.19 
12   36 
23.44493   28333.19 
12   36 
23.4449   28333.22 
12   36 
23.44537   37508.18 
12   36 
23.4454   37508.18 
12   36 
23.44537   37508.21 
12   36 
23.44633   49628.76 
12   36 
23.44636   49628.76 
12   36 
23.44633   49628.81 
12   36 
23.44711   65581.36 
12   36 
23.44713   65581.36 
12   36 
23.44711   65581.42 
12   36 
23.44736   86528.12 
12   36 
23.44738   86528.12 
12   36 
23.44736   86528.21 
12   36 
23.44714   115085.6 
12   36 
23.44716   115085.6 
12   36 
23.44714   115085.7 
12   36 
23.44671   151197.8 
12   36 
23.44674   151197.8 
12   36 
23.44671   151198 
12   36 
23.44635   200444.8 
12   36 
23.44637   200444.8 
12   36 
23.44635   200445 
12   36 
23.4462   266754.5 
12   36 
23.44623   266754.5 
12   36 
23.4462   266754.7 
12   36 
23.4463   332875.9 
12   36 
23.44633   332875.9 
12   36 
23.4463   332876.2 
12   36 
23.44646   435439.1 
12   36 
23.44648   435439.1 
12   36 
23.44646   435439.5 
12   36 
23.44656   538002.3 
12   36 
23.44658   538002.3 
12   36 
23.44656   538002.8 
12   36 
23.4466   640565.5 
12   36 
23.44663   640565.5 
12   36 
23.4466   640566.1 
12   36 
23.44661   743128.7 
12   36 
23.44664   743128.7 
12   36 
23.44661   743129.5 
12   36 
23.4466   845691.9 
12   36 
23.44662   845691.9 
12   36 
23.4466   845692.8 
Fit Mean:  23.4466  Size:  845691.9  Code:  5 
Try Mean:  22.78621  Size:  10 
12   36 
22.78621   10 
12   36 
22.78621   10 
12   36 
22.78623   10 
12   36 
22.78621   10.00001 
12   36 
22.78748   10.00053 
12   36 
22.7875   10.00053 
12   36 
22.78748   10.00054 
12   36 
24.92798   11.9189 
12   36 
24.928   11.9189 
12   36 
24.92798   11.91891 
12   36 
25.03476   12.74887 
12   36 
25.03479   12.74887 
12   36 
25.03476   12.74888 
12   36 
24.74883   17.91948 
12   36 
24.74885   17.91948 
12   36 
24.74883   17.9195 
12   36 
23.44469   28.08885 
12   36 
23.44471   28.08885 
12   36 
23.44469   28.08888 
12   36 
23.46946   32.66211 
12   36 
23.46948   32.66211 
12   36 
23.46946   32.66214 
12   36 
23.7411   45.11 
12   36 
23.74112   45.11 
12   36 
23.7411   45.11004 
12   36 
23.52337   58.95206 
12   36 
23.52339   58.95206 
12   36 
23.52337   58.95211 
12   36 
23.56513   76.74216 
12   36 
23.56515   76.74216 
12   36 
23.56513   76.74223 
12   36 
23.51713   98.81573 
12   36 
23.51715   98.81573 
12   36 
23.51713   98.81583 
12   36 
23.51871   127.0899 
12   36 
23.51873   127.0899 
12   36 
23.51871   127.09 
12   36 
23.48712   163.1788 
12   36 
23.48714   163.1788 
12   36 
23.48712   163.179 
12   36 
23.49465   209.6129 
12   36 
23.49467   209.6129 
12   36 
23.49465   209.6132 
12   36 
23.46506   269.9261 
12   36 
23.46509   269.9261 
12   36 
23.46506   269.9263 
12   36 
23.48121   348.5454 
12   36 
23.48123   348.5454 
12   36 
23.48121   348.5458 
12   36 
23.45285   452.0663 
12   36 
23.45287   452.0663 
12   36 
23.45285   452.0667 
12   36 
23.46679   587.3127 
12   36 
23.46681   587.3127 
12   36 
23.46679   587.3133 
12   36 
23.45261   764.2837 
12   36 
23.45264   764.2837 
12   36 
23.45261   764.2845 
12   36 
23.45579   996.9239 
12   36 
23.45581   996.9239 
12   36 
23.45579   996.9249 
12   36 
23.45133   1303.031 
12   36 
23.45135   1303.031 
12   36 
23.45133   1303.033 
12   36 
23.45128   1707.821 
12   36 
23.45131   1707.821 
12   36 
23.45128   1707.823 
12   36 
23.44955   2242.621 
12   36 
23.44958   2242.621 
12   36 
23.44955   2242.623 
12   36 
23.44912   2950.598 
12   36 
23.44915   2950.598 
12   36 
23.44912   2950.601 
12   36 
23.44832   3887.587 
12   36 
23.44834   3887.587 
12   36 
23.44832   3887.591 
12   36 
23.44797   5128.459 
12   36 
23.448   5128.459 
12   36 
23.44797   5128.464 
12   36 
23.44757   6771.778 
12   36 
23.44759   6771.778 
12   36 
23.44757   6771.785 
12   36 
23.44734   8948.37 
12   36 
23.44736   8948.37 
12   36 
23.44734   8948.378 
12   36 
23.44712   11831.68 
12   36 
23.44715   11831.68 
12   36 
23.44712   11831.69 
12   36 
23.44699   15650.41 
12   36 
23.44701   15650.41 
12   36 
23.44699   15650.43 
12   36 
23.44687   20710.06 
12   36 
23.44689   20710.06 
12   36 
23.44687   20710.08 
12   36 
23.44678   27409.45 
12   36 
23.44681   27409.45 
12   36 
23.44678   27409.47 
12   36 
23.44672   36296.98 
12   36 
23.44674   36296.98 
12   36 
23.44672   36297.02 
12   36 
23.44667   48066.77 
12   36 
23.44669   48066.77 
12   36 
23.44667   48066.82 
12   36 
23.44663   63590.13 
12   36 
23.44666   63590.13 
12   36 
23.44663   63590.19 
12   36 
23.44661   84406.58 
12   36 
23.44663   84406.58 
12   36 
23.44661   84406.66 
12   36 
23.44659   109290.5 
12   36 
23.44661   109290.5 
12   36 
23.44659   109290.6 
12   36 
23.44658   134174.5 
12   36 
23.4466   134174.5 
12   36 
23.44658   134174.6 
Fit Mean:  23.44658  Size:  134174.5  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  23.44658  Size:  134174.5  Code:  1  Try Size:  10 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
12 36
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
134174.5   23.44658 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 134174.5
> print(nb_fit_mu);
[1] 23.44658
> 
> print(m)
[1] 25.76608
> print(v)
[1] 88.3332
> print(D)
[1] 3.428274
> 
> print(deletion_propagation_coverage)
[1] 11
> 
> warnings()
> 
