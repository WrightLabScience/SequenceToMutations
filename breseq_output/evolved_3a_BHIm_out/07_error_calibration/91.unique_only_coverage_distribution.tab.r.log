
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | 3a-_BHI_c50_out/07_error_calibration/91.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | 3a-_BHI_c50_out/output/calibration/91.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.00281272 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 3 to 9.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  4.971429  Size:  10000 
3   9 
4.971429   10000 
3   9 
4.971429   10000 
3   9 
4.971434   10000 
3   9 
4.971429   10000.01 
3   9 
4.964818   10000 
3   9 
4.964823   10000 
3   9 
4.964818   10000.01 
3   9 
4.785418   10000 
3   9 
4.785423   10000 
3   9 
4.785418   10000.01 
3   9 
4.793824   10000 
3   9 
4.793829   10000 
3   9 
4.793824   10000.01 
3   9 
4.793471   10000 
3   9 
4.793476   10000 
3   9 
4.793471   10000.01 
3   9 
4.793471   10000 
3   9 
4.793951   10000 
3   9 
4.792992   10000 
3   9 
4.793471   10001 
3   9 
4.793471   9999 
3   9 
4.793473   10000 
3   9 
4.793953   10000 
3   9 
4.792994   10000 
3   9 
4.793473   10001 
3   9 
4.793473   9999 
Fit Mean:  4.793473  Size:  10000  Code:  2 
Try Mean:  4.971429  Size:  1000 
3   9 
4.971429   1000 
3   9 
4.971429   1000 
3   9 
4.971434   1000 
3   9 
4.971429   1000.001 
3   9 
4.964848   1000 
3   9 
4.964853   1000 
3   9 
4.964848   1000.001 
3   9 
4.785124   1000 
3   9 
4.785129   1000 
3   9 
4.785124   1000.001 
3   9 
4.793603   1000 
3   9 
4.793608   1000 
3   9 
4.793603   1000.001 
3   9 
4.793245   1000 
3   9 
4.79325   1000 
3   9 
4.793245   1000.001 
3   9 
4.793245   1000 
3   9 
4.793249   1000 
3   9 
4.793245   1000.001 
Fit Mean:  4.793245  Size:  1000  Code:  2 
Try Mean:  4.971429  Size:  100 
3   9 
4.971429   100 
3   9 
4.971429   100 
3   9 
4.971434   100 
3   9 
4.971429   100.0001 
3   9 
4.965137   100 
3   9 
4.965142   100 
3   9 
4.965137   100.0001 
3   9 
4.782383   100.0006 
3   9 
4.782388   100.0006 
3   9 
4.782383   100.0007 
3   9 
4.791572   100.0009 
3   9 
4.791577   100.0009 
3   9 
4.791572   100.001 
3   9 
4.791168   100.0012 
3   9 
4.791173   100.0012 
3   9 
4.791168   100.0013 
3   9 
4.790969   100.0017 
3   9 
4.790974   100.0017 
3   9 
4.790969   100.0018 
3   9 
4.79037   100.0053 
3   9 
4.790375   100.0053 
3   9 
4.79037   100.0054 
3   9 
4.789572   100.0141 
3   9 
4.789576   100.0141 
3   9 
4.789572   100.0142 
3   9 
4.788176   100.0409 
3   9 
4.788181   100.0409 
3   9 
4.788176   100.041 
3   9 
4.785989   100.1123 
3   9 
4.785994   100.1123 
3   9 
4.785989   100.1124 
3   9 
4.782434   100.3055 
3   9 
4.782439   100.3055 
3   9 
4.782434   100.3056 
3   9 
4.776801   100.8136 
3   9 
4.776806   100.8136 
3   9 
4.776801   100.8137 
3   9 
4.768044   102.1334 
3   9 
4.768049   102.1334 
3   9 
4.768044   102.1335 
3   9 
4.755287   105.4474 
3   9 
4.755292   105.4474 
3   9 
4.755287   105.4475 
3   9 
4.739264   113.3016 
3   9 
4.739269   113.3016 
3   9 
4.739264   113.3017 
3   9 
4.725351   130.4135 
3   9 
4.725356   130.4135 
3   9 
4.725351   130.4136 
3   9 
4.725771   164.6805 
3   9 
4.725776   164.6805 
3   9 
4.725771   164.6806 
3   9 
4.753065   223.7312 
3   9 
4.753069   223.7312 
3   9 
4.753065   223.7314 
3   9 
4.789823   297.1577 
3   9 
4.789828   297.1577 
3   9 
4.789823   297.158 
3   9 
4.810615   365.7593 
3   9 
4.81062   365.7593 
3   9 
4.810615   365.7597 
3   9 
4.819328   445.8422 
3   9 
4.819332   445.8422 
3   9 
4.819328   445.8427 
3   9 
4.818034   577.5997 
3   9 
4.818039   577.5997 
3   9 
4.818034   577.6003 
3   9 
4.805655   775.3804 
3   9 
4.80566   775.3804 
3   9 
4.805655   775.3812 
3   9 
4.79179   1017.494 
3   9 
4.791795   1017.494 
3   9 
4.79179   1017.495 
3   9 
4.784135   1283.371 
3   9 
4.78414   1283.371 
3   9 
4.784135   1283.372 
3   9 
4.782025   1640.698 
3   9 
4.782029   1640.698 
3   9 
4.782025   1640.699 
3   9 
4.785327   2176.975 
3   9 
4.785332   2176.975 
3   9 
4.785327   2176.977 
3   9 
4.791542   2898.397 
3   9 
4.791547   2898.397 
3   9 
4.791542   2898.399 
3   9 
4.796333   3758.985 
3   9 
4.796338   3758.985 
3   9 
4.796333   3758.988 
3   9 
4.798406   4833.631 
3   9 
4.798411   4833.631 
3   9 
4.798406   4833.636 
3   9 
4.797879   6354.673 
3   9 
4.797883   6354.673 
3   9 
4.797879   6354.679 
3   9 
4.795426   8463.741 
3   9 
4.795431   8463.741 
3   9 
4.795426   8463.749 
3   9 
4.792869   11138.2 
3   9 
4.792874   11138.2 
3   9 
4.792869   11138.21 
3   9 
4.791424   14454 
3   9 
4.791429   14454 
3   9 
4.791424   14454.01 
3   9 
4.791257   18913.79 
3   9 
4.791262   18913.79 
3   9 
4.791257   18913.81 
3   9 
4.792157   25049.66 
3   9 
4.792162   25049.66 
3   9 
4.792157   25049.68 
3   9 
4.793433   33396.45 
3   9 
4.793437   33396.45 
3   9 
4.793433   33396.48 
3   9 
4.794281   43394.69 
3   9 
4.794285   43394.69 
3   9 
4.794281   43394.74 
3   9 
4.79455   56702 
3   9 
4.794555   56702 
3   9 
4.79455   56702.06 
3   9 
4.794254   73248.35 
3   9 
4.794259   73248.35 
3   9 
4.794254   73248.42 
3   9 
4.793633   101112.8 
3   9 
4.793638   101112.8 
3   9 
4.793633   101112.9 
3   9 
4.793235   129090.3 
3   9 
4.79324   129090.3 
3   9 
4.793235   129090.4 
3   9 
4.793036   169955.9 
3   9 
4.79304   169955.9 
3   9 
4.793036   169956 
3   9 
4.792945   270079.3 
3   9 
4.79295   270079.3 
3   9 
4.792945   270079.6 
3   9 
4.793199   261326.3 
3   9 
4.793011   267826.3 
3   9 
4.792961   269541.3 
3   9 
4.792949   269947 
3   9 
4.792946   270046.8 
3   9 
4.792946   270071.4 
3   9 
4.792946   270077.4 
3   9 
4.792945   270078.9 
3   9 
4.792945   270079.2 
3   9 
4.793425   270079.3 
3   9 
4.792466   270079.3 
3   9 
4.792945   270106.4 
3   9 
4.792945   270052.3 
3   9 
4.793182   299788.7 
3   9 
4.793661   299788.7 
3   9 
4.792702   299788.7 
3   9 
4.793182   299818.7 
3   9 
4.793182   299758.8 
3   9 
4.793733   399912.2 
3   9 
4.794212   399912.2 
3   9 
4.793253   399912.2 
3   9 
4.793733   399952.2 
3   9 
4.793733   399872.3 
3   9 
4.793953   500035.7 
3   9 
4.794433   500035.7 
3   9 
4.793474   500035.7 
3   9 
4.793953   500085.8 
3   9 
4.793953   499985.7 
3   9 
4.793956   600159.2 
3   9 
4.794436   600159.2 
3   9 
4.793477   600159.2 
3   9 
4.793956   600219.3 
3   9 
4.793956   600099.2 
3   9 
4.793865   700282.7 
3   9 
4.794344   700282.7 
3   9 
4.793385   700282.7 
3   9 
4.793865   700352.8 
3   9 
4.793865   700212.7 
3   9 
4.793756   800406.2 
3   9 
4.794235   800406.2 
3   9 
4.793277   800406.2 
3   9 
4.793756   800486.3 
3   9 
4.793756   800326.2 
Fit Mean:  4.793756  Size:  800406.2  Code:  5 
Try Mean:  4.971429  Size:  10 
3   9 
4.971429   10 
3   9 
4.971429   10 
3   9 
4.971434   10 
3   9 
4.971429   10.00001 
3   9 
4.967488   10.00069 
3   9 
4.967493   10.00069 
3   9 
4.967488   10.0007 
3   9 
4.763221   10.07621 
3   9 
4.763225   10.07621 
3   9 
4.763221   10.07622 
3   9 
4.772813   10.11206 
3   9 
4.772818   10.11206 
3   9 
4.772813   10.11207 
3   9 
4.881223   11.07299 
3   9 
4.881228   11.07299 
3   9 
4.881223   11.073 
3   9 
4.948733   12.72789 
3   9 
4.948738   12.72789 
3   9 
4.948733   12.72791 
3   9 
4.965016   16.41605 
3   9 
4.965021   16.41605 
3   9 
4.965016   16.41607 
3   9 
4.869882   22.98545 
3   9 
4.869887   22.98545 
3   9 
4.869882   22.98547 
3   9 
4.757791   31.13614 
3   9 
4.757795   31.13614 
3   9 
4.757791   31.13617 
3   9 
4.73038   39.07201 
3   9 
4.730385   39.07201 
3   9 
4.73038   39.07205 
3   9 
4.750934   52.59343 
3   9 
4.750938   52.59343 
3   9 
4.750934   52.59348 
3   9 
4.78841   70.35845 
3   9 
4.788415   70.35845 
3   9 
4.78841   70.35852 
3   9 
4.806674   92.4504 
3   9 
4.806679   92.4504 
3   9 
4.806674   92.45049 
3   9 
4.805876   122.4699 
3   9 
4.805881   122.4699 
3   9 
4.805876   122.4701 
3   9 
4.796223   162.9519 
3   9 
4.796228   162.9519 
3   9 
4.796223   162.952 
3   9 
4.789535   215.7743 
3   9 
4.78954   215.7743 
3   9 
4.789535   215.7745 
3   9 
4.788857   285.8918 
3   9 
4.788862   285.8918 
3   9 
4.788857   285.8921 
3   9 
4.791412   379.3185 
3   9 
4.791417   379.3185 
3   9 
4.791412   379.3189 
3   9 
4.793657   502.77 
3   9 
4.793662   502.77 
3   9 
4.793657   502.7705 
3   9 
4.794286   666.2258 
3   9 
4.79429   666.2258 
3   9 
4.794286   666.2265 
3   9 
4.793851   882.983 
3   9 
4.793856   882.983 
3   9 
4.793851   882.9839 
3   9 
4.793313   1170.06 
3   9 
4.793317   1170.06 
3   9 
4.793313   1170.061 
3   9 
4.793133   1550.3 
3   9 
4.793138   1550.3 
3   9 
4.793133   1550.301 
3   9 
4.793247   2054.193 
3   9 
4.793251   2054.193 
3   9 
4.793247   2054.195 
3   9 
4.793417   2721.492 
3   9 
4.793422   2721.492 
3   9 
4.793417   2721.494 
3   9 
4.793505   3605.55 
3   9 
4.793509   3605.55 
3   9 
4.793505   3605.554 
3   9 
4.793506   4776.598 
3   9 
4.793511   4776.598 
3   9 
4.793506   4776.603 
3   9 
4.793479   6328.013 
3   9 
4.793484   6328.013 
3   9 
4.793479   6328.019 
3   9 
4.793464   8385.014 
3   9 
4.793469   8385.014 
3   9 
4.793464   8385.023 
3   9 
4.793468   11102.62 
3   9 
4.793473   11102.62 
3   9 
4.793468   11102.64 
3   9 
4.79348   14717.98 
3   9 
4.793485   14717.98 
3   9 
4.79348   14717.99 
3   9 
4.793489   19479.98 
3   9 
4.793494   19479.98 
3   9 
4.793489   19480 
3   9 
4.793493   25843.23 
3   9 
4.793497   25843.23 
3   9 
4.793493   25843.26 
3   9 
4.793492   34122.9 
3   9 
4.793497   34122.9 
3   9 
4.793492   34122.93 
3   9 
4.793492   44998.96 
3   9 
4.793497   44998.96 
3   9 
4.793492   44999.01 
3   9 
4.793492   56166.55 
3   9 
4.793497   56166.55 
3   9 
4.793492   56166.61 
3   9 
4.793493   67334.15 
3   9 
4.793498   67334.15 
3   9 
4.793493   67334.21 
3   9 
4.793493   78501.74 
3   9 
4.793498   78501.74 
3   9 
4.793493   78501.82 
3   9 
4.793494   89669.33 
3   9 
4.793499   89669.33 
3   9 
4.793494   89669.42 
3   9 
4.793494   100836.9 
3   9 
4.793499   100836.9 
3   9 
4.793494   100837 
Fit Mean:  4.793494  Size:  100836.9  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  4.793494  Size:  100836.9  Code:  1  Try Size:  10 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
3 9
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
100836.9   4.793494 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 100836.9
> print(nb_fit_mu);
[1] 4.793494
> 
> print(m)
[1] 25.71064
> print(v)
[1] 285.8732
> print(D)
[1] 11.11887
> 
> print(deletion_propagation_coverage)
[1] 1
> 
> warnings()
> 
