
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | 3a-_BHI_c50_out/07_error_calibration/57.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | 3a-_BHI_c50_out/output/calibration/57.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.000900061 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 52 to 158.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  102.218  Size:  10000 
52   158 
102.218   10000 
52   158 
102.218   10000 
52   158 
102.2181   10000 
52   158 
102.218   10000.01 
52   158 
102.2184   10000 
52   158 
102.2185   10000 
52   158 
102.2184   10000.01 
52   158 
109.1474   10000 
52   158 
109.1475   10000 
52   158 
109.1474   10000.01 
52   158 
108.1135   9999.999 
52   158 
108.1136   9999.999 
52   158 
108.1135   10000.01 
52   158 
108.1826   9999.999 
52   158 
108.1827   9999.999 
52   158 
108.1826   10000.01 
52   158 
108.1827   9999.999 
52   158 
108.1828   9999.999 
52   158 
108.1827   10000.01 
Fit Mean:  108.1827  Size:  9999.999  Code:  2 
Try Mean:  102.218  Size:  1000 
52   158 
102.218   1000 
52   158 
102.218   1000 
52   158 
102.2181   1000 
52   158 
102.218   1000.001 
52   158 
102.2184   1000 
52   158 
102.2185   1000 
52   158 
102.2184   1000.001 
52   158 
108.9449   999.9671 
52   158 
108.945   999.9671 
52   158 
108.9449   999.9681 
52   158 
108.0782   999.9549 
52   158 
108.0783   999.9549 
52   158 
108.0782   999.9559 
52   158 
108.1272   999.9394 
52   158 
108.1273   999.9394 
52   158 
108.1272   999.9404 
52   158 
108.1317   999.9203 
52   158 
108.1318   999.9203 
52   158 
108.1317   999.9213 
52   158 
108.1849   999.4602 
52   158 
108.185   999.4602 
52   158 
108.1849   999.4612 
52   158 
108.2428   998.4799 
52   158 
108.2429   998.4799 
52   158 
108.2428   998.4809 
52   158 
108.3548   995.1736 
52   158 
108.3549   995.1736 
52   158 
108.3548   995.1746 
52   158 
108.529   986.476 
52   158 
108.5291   986.476 
52   158 
108.529   986.477 
52   158 
108.8366   961.6001 
52   158 
108.8367   961.6001 
52   158 
108.8366   961.6011 
52   158 
109.4302   888.3472 
52   158 
109.4303   888.3472 
52   158 
109.4302   888.3481 
52   158 
111.2795   585.5992 
52   158 
111.2796   585.5992 
52   158 
111.2795   585.5998 
52   158 
114.4888   41.64452 
52   158 
114.4889   41.64452 
52   158 
114.4888   41.64456 
Fit Mean:  277.295  Size:  -23969.62  Code:  1 
Try Mean:  102.218  Size:  100 
52   158 
102.218   100 
52   158 
102.218   100 
52   158 
102.2181   100 
52   158 
102.218   100.0001 
52   158 
102.2182   99.99997 
52   158 
102.2183   99.99997 
52   158 
102.2182   100.0001 
52   158 
107.4952   98.82987 
52   158 
107.4953   98.82987 
52   158 
107.4952   98.82997 
52   158 
107.4555   98.25965 
52   158 
107.4557   98.25965 
52   158 
107.4555   98.25974 
52   158 
107.451   97.67919 
52   158 
107.4511   97.67919 
52   158 
107.451   97.67929 
52   158 
107.4468   97.09587 
52   158 
107.4469   97.09587 
52   158 
107.4468   97.09596 
52   158 
107.4426   96.50974 
52   158 
107.4427   96.50974 
52   158 
107.4426   96.50983 
52   158 
107.4384   95.92078 
52   158 
107.4385   95.92078 
52   158 
107.4384   95.92088 
52   158 
107.434   95.32897 
52   158 
107.4341   95.32897 
52   158 
107.434   95.32907 
52   158 
107.4296   94.73429 
52   158 
107.4297   94.73429 
52   158 
107.4296   94.73438 
52   158 
107.4252   94.13669 
52   158 
107.4253   94.13669 
52   158 
107.4252   94.13679 
52   158 
107.4206   93.53617 
52   158 
107.4207   93.53617 
52   158 
107.4206   93.53626 
52   158 
107.416   92.93268 
52   158 
107.4161   92.93268 
52   158 
107.416   92.93278 
52   158 
107.4113   92.32621 
52   158 
107.4115   92.32621 
52   158 
107.4113   92.32631 
52   158 
107.4066   91.71673 
52   158 
107.4067   91.71673 
52   158 
107.4066   91.71682 
52   158 
107.4018   91.10421 
52   158 
107.4019   91.10421 
52   158 
107.4018   91.1043 
52   158 
107.3969   90.48862 
52   158 
107.397   90.48862 
52   158 
107.3969   90.48871 
52   158 
107.3919   89.86994 
52   158 
107.392   89.86994 
52   158 
107.3919   89.87003 
52   158 
107.3868   89.24814 
52   158 
107.3869   89.24814 
52   158 
107.3868   89.24823 
52   158 
107.3817   88.62319 
52   158 
107.3818   88.62319 
52   158 
107.3817   88.62328 
52   158 
107.3765   87.99507 
52   158 
107.3766   87.99507 
52   158 
107.3765   87.99516 
52   158 
107.3712   87.36375 
52   158 
107.3713   87.36375 
52   158 
107.3712   87.36384 
52   158 
107.3658   86.72921 
52   158 
107.3659   86.72921 
52   158 
107.3658   86.72929 
52   158 
107.3603   86.09141 
52   158 
107.3604   86.09141 
52   158 
107.3603   86.09149 
52   158 
107.3547   85.45033 
52   158 
107.3548   85.45033 
52   158 
107.3547   85.45042 
52   158 
107.349   84.80595 
52   158 
107.3491   84.80595 
52   158 
107.349   84.80604 
52   158 
107.3432   84.15824 
52   158 
107.3433   84.15824 
52   158 
107.3432   84.15833 
52   158 
107.3374   83.50718 
52   158 
107.3375   83.50718 
52   158 
107.3374   83.50726 
52   158 
107.3314   82.85274 
52   158 
107.3315   82.85274 
52   158 
107.3314   82.85282 
52   158 
107.3253   82.1949 
52   158 
107.3254   82.1949 
52   158 
107.3253   82.19498 
52   158 
107.3191   81.53363 
52   158 
107.3192   81.53363 
52   158 
107.3191   81.53371 
52   158 
107.3128   80.86892 
52   158 
107.3129   80.86892 
52   158 
107.3128   80.869 
52   158 
107.3064   80.20074 
52   158 
107.3065   80.20074 
52   158 
107.3064   80.20082 
52   158 
107.2999   79.52907 
52   158 
107.3   79.52907 
52   158 
107.2999   79.52915 
52   158 
107.2933   78.85389 
52   158 
107.2934   78.85389 
52   158 
107.2933   78.85397 
52   158 
107.2865   78.17518 
52   158 
107.2866   78.17518 
52   158 
107.2865   78.17526 
52   158 
107.2796   77.49293 
52   158 
107.2797   77.49293 
52   158 
107.2796   77.493 
52   158 
107.2726   76.80711 
52   158 
107.2727   76.80711 
52   158 
107.2726   76.80719 
52   158 
107.2655   76.11772 
52   158 
107.2656   76.11772 
52   158 
107.2655   76.1178 
52   158 
107.2582   75.42475 
52   158 
107.2583   75.42475 
52   158 
107.2582   75.42482 
52   158 
107.2508   74.72817 
52   158 
107.2509   74.72817 
52   158 
107.2508   74.72824 
52   158 
107.2433   74.02798 
52   158 
107.2434   74.02798 
52   158 
107.2433   74.02806 
52   158 
107.2356   73.32418 
52   158 
107.2357   73.32418 
52   158 
107.2356   73.32425 
52   158 
107.2278   72.61676 
52   158 
107.2279   72.61676 
52   158 
107.2278   72.61683 
52   158 
107.2198   71.90571 
52   158 
107.2199   71.90571 
52   158 
107.2198   71.90578 
52   158 
107.2117   71.19104 
52   158 
107.2118   71.19104 
52   158 
107.2117   71.19111 
52   158 
107.2034   70.47276 
52   158 
107.2035   70.47276 
52   158 
107.2034   70.47283 
52   158 
107.195   69.75086 
52   158 
107.1951   69.75086 
52   158 
107.195   69.75093 
52   158 
107.1864   69.02536 
52   158 
107.1865   69.02536 
52   158 
107.1864   69.02543 
52   158 
107.1776   68.29628 
52   158 
107.1777   68.29628 
52   158 
107.1776   68.29635 
52   158 
107.1686   67.56364 
52   158 
107.1688   67.56364 
52   158 
107.1686   67.5637 
52   158 
107.1595   66.82745 
52   158 
107.1596   66.82745 
52   158 
107.1595   66.82751 
52   158 
107.1502   66.08774 
52   158 
107.1504   66.08774 
52   158 
107.1502   66.08781 
52   158 
107.1408   65.34456 
52   158 
107.1409   65.34456 
52   158 
107.1408   65.34462 
52   158 
107.1311   64.59794 
52   158 
107.1312   64.59794 
52   158 
107.1311   64.598 
52   158 
107.1213   63.84792 
52   158 
107.1214   63.84792 
52   158 
107.1213   63.84799 
52   158 
107.1113   63.09457 
52   158 
107.1114   63.09457 
52   158 
107.1113   63.09464 
52   158 
107.101   62.33795 
52   158 
107.1011   62.33795 
52   158 
107.101   62.33801 
52   158 
107.0906   61.57811 
52   158 
107.0907   61.57811 
52   158 
107.0906   61.57818 
52   158 
107.08   60.81515 
52   158 
107.0801   60.81515 
52   158 
107.08   60.81522 
52   158 
107.0692   60.04915 
52   158 
107.0693   60.04915 
52   158 
107.0692   60.04921 
52   158 
107.0582   59.28022 
52   158 
107.0583   59.28022 
52   158 
107.0582   59.28027 
52   158 
107.0469   58.50844 
52   158 
107.047   58.50844 
52   158 
107.0469   58.5085 
52   158 
107.0355   57.73397 
52   158 
107.0356   57.73397 
52   158 
107.0355   57.73402 
52   158 
107.0239   56.95692 
52   158 
107.024   56.95692 
52   158 
107.0239   56.95697 
52   158 
107.012   56.17744 
52   158 
107.0121   56.17744 
52   158 
107.012   56.1775 
52   158 
106.9999   55.39571 
52   158 
107   55.39571 
52   158 
106.9999   55.39576 
52   158 
106.9877   54.61189 
52   158 
106.9878   54.61189 
52   158 
106.9877   54.61195 
52   158 
106.9752   53.8262 
52   158 
106.9753   53.8262 
52   158 
106.9752   53.82625 
52   158 
106.9625   53.03884 
52   158 
106.9626   53.03884 
52   158 
106.9625   53.03889 
52   158 
106.9496   52.25005 
52   158 
106.9497   52.25005 
52   158 
106.9496   52.2501 
52   158 
106.9365   51.46009 
52   158 
106.9366   51.46009 
52   158 
106.9365   51.46014 
52   158 
106.9232   50.66924 
52   158 
106.9233   50.66924 
52   158 
106.9232   50.66929 
52   158 
106.9097   49.8778 
52   158 
106.9098   49.8778 
52   158 
106.9097   49.87785 
52   158 
106.8961   49.08611 
52   158 
106.8962   49.08611 
52   158 
106.8961   49.08616 
Fit Mean:  -66.85314  Size:  -9890.191  Code:  1 
Try Mean:  102.218  Size:  10 
52   158 
102.218   10 
52   158 
102.218   10 
52   158 
102.2181   10 
52   158 
102.218   10.00001 
52   158 
102.2181   10.00013 
52   158 
102.2182   10.00013 
52   158 
102.2181   10.00014 
52   158 
108.0116   16.26293 
52   158 
108.0117   16.26293 
52   158 
108.0116   16.26294 
52   158 
107.5984   17.63403 
52   158 
107.5985   17.63403 
52   158 
107.5984   17.63405 
52   158 
106.1351   20.76396 
52   158 
106.1352   20.76396 
52   158 
106.1351   20.76398 
52   158 
106.4778   21.25825 
52   158 
106.478   21.25825 
52   158 
106.4778   21.25827 
52   158 
106.4853   21.4935 
52   158 
106.4854   21.4935 
52   158 
106.4853   21.49352 
52   158 
106.4833   21.50792 
52   158 
106.4834   21.50792 
52   158 
106.4833   21.50794 
Fit Mean:  106.4833  Size:  21.50792  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  106.4833  Size:  21.50792  Code:  1  Try Size:  10 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
52 158
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
21.50792   106.4833 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 21.50792
> print(nb_fit_mu);
[1] 106.4833
> 
> print(m)
[1] 105.9292
> print(v)
[1] 787.5724
> print(D)
[1] 7.434897
> 
> print(deletion_propagation_coverage)
[1] 43
> 
> warnings()
> 
