
R version 4.3.1 (2023-06-16) -- "Beagle Scouts"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ##
> ##
> ## AUTHORS
> ##
> ## Jeffrey E. Barrick <jeffrey.e.barrick@gmail.com>
> ##
> ## LICENSE AND COPYRIGHT
> ##
> ## Copyright (c) 2008-2010 Michigan State University
> ## Copyright (c) 2011-2022 The University of Texas at Austin
> ##
> ## breseq is free software; you can redistribute it and/or modify it under the
> ## terms the GNU General Public License as published by the Free Software
> ## Foundation; either version 1, or (at your option) any later version.
> ##
> ##
> 
> ## Arguments:
> ##   distribution_file=/path/to/input 
> ##   plot_file=/path/to/output 
> ##   deletion_propagation_pr_cutoff=float
> ##   plot_poisson=0 or 1
> ##   pdf_output=0 or 1
> 
> ## Returns these values printed out to output log
> ## 
> ##  1. print(nb_fit_size); # 0 if fit failed
> ##  2. print(nb_fit_mu);   # 0 if fit failed
> ##  3. print(m)q
> ##  4. print(v)
> ##  5. print(D)
> ##  6. print(deletion_propagation_coverage)
> ##     -1 if it was <1 after fitting (implying reference sequence is deleted)
> ##
> 
> plot_poisson = 0;
> pdf_output = 1;
> 
> this.print.level = 0
> #this.print.level = 2
> 
> for (e in commandArgs(TRUE)) {
+   ta = strsplit(e,"=",fixed=TRUE)[[1]]
+   if(length(ta)>1) {
+     temp = ta[2]
+     assign(ta[1],temp)
+     cat("assigned ",ta[1]," the value of |",temp,"|\n")
+   } else {
+     assign(ta[[1]][1],TRUE)
+     cat("assigned ",ta[1]," the value of TRUE\n")
+   }
+ }
assigned  distribution_file  the value of | 3a-_BHI_c50_out/07_error_calibration/71.unique_only_coverage_distribution.tab |
assigned  plot_file  the value of | 3a-_BHI_c50_out/output/calibration/71.unique_coverage.pdf |
assigned  deletion_propagation_pr_cutoff  the value of | 0.00187912 |
> 
> deletion_propagation_pr_cutoff = as.numeric(deletion_propagation_pr_cutoff);
> 
> ## initialize values to be filled in
> nb_fit_mu = 0
> nb_fit_size = 0
> m = 0
> v = 0
> D = 0
> deletion_propagation_coverage = -1
> 
> min_fraction_included_in_nb_fit = 0.01
> 
> #load data
> X<-read.table(distribution_file, header=T)
> 
> #table might be empty
> if (nrow(X) == 0)
+ {
+   #print out statistics
+   
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> #create the distribution vector and fit
> Y<-rep(X$coverage, X$n)
> m<-mean(Y)
> v<-var(Y)
> D<-v/m
> 
> ###
> ## Smooth the distribution with a moving average window of size 5
> ## so that we can more reliably find it's maximum value
> ###
> 
> ma5 = c(1, 1, 1, 1, 1)/5;
> 
> ## filtering fails if there are too few points
> if (nrow(X) >= 5) {
+   X$ma = filter(X$n, ma5)
+ } else {
+ 	X$ma = X$n
+ }
> 
> i<-0
> max_n <- 0;
> min_i <- max( trunc(m/4), 1 ); #prevents zero for pathological distributions
> max_i <- i;
> for (i in min_i:length(X$ma))
+ {		
+   #cat(i, "\n")
+ 	if (!is.na(X$ma[i]) && (X$ma[i] > max_n))
+ 	{
+ 		max_n = X$ma[i];
+ 		max_i = i;
+ 	}
+ }
> 
> ##
> # Censor data on the right and left of the maximum
> ##
> 
> start_i = max(floor(max_i*0.5), 1);
> end_i = min(ceiling(max_i*1.5), length(X$ma));
> 
> if (start_i == end_i)
+ {
+   print(nb_fit_size);
+   print(nb_fit_mu);
+   
+   print(m)
+   print(v)
+   print(D)
+   
+   print(deletion_propagation_coverage)
+   
+   q()
+ }
> 
> cat("Fitting from coverage of ", start_i, " to ", end_i, ".\n", sep="")
Fitting from coverage of 11 to 35.
> 
> ##
> # Coarse grain so that we are only fitting a number of bins that is 1000-2000
> #
> # The later adjustment for doing the fits this way is to multiply the means
> # of the negative binomial and poisson distributions by the binning number.
> # (The size parameter of the negative binomial doesn't need to be adjusted.)
> ##
> 
> 
> num_per_bin = trunc((end_i - start_i) / 1000)
> 
> if (num_per_bin > 1) 
+ {
+   cat("Coarse-graining for fits\n")
+   start_i_for_fits = trunc(start_i/num_per_bin)
+   end_i_for_fits = ceiling(end_i/num_per_bin)
+   num_bins = end_i - start_i  + 1
+   cat("Fitting from coverage in adjusted bins ", start_i_for_fits, " to ", end_i_for_fits, ".\n", sep="")
+   cat("Number of bins ", num_bins, ". Each bin has ", num_per_bin, " coverage values.\n", sep="")
+ 
+   # Create a new vector where we've added together values in bins
+   X.for.fits = vector("double", end_i_for_fits)
+   for (i in start_i_for_fits:end_i_for_fits)
+   {
+     for (j in 1:num_per_bin)
+     {
+       if (i*num_per_bin+j <= length(X$n))
+       {
+         X.for.fits[i] = X.for.fits[i] + X$n[i*num_per_bin+j]
+       }
+     }
+   }
+ 
+ } else {
+   ## AVOID num_per_bin equalling zero!!
+   X.for.fits = X$n[1:end_i]
+   num_per_bin = 1
+   start_i_for_fits = start_i
+   end_i_for_fits = end_i
+ }
> 
> 
> ##
> # Now perform negative binomial fitting to the censored data
> ##
> 
> inner_total<-0;
> for (i in start_i_for_fits:end_i_for_fits)
+ {
+ 	inner_total = inner_total + X.for.fits[i]; 
+ }
> # Yes: it's correct to use X here because we want the overall total total
> total_total<-sum(X$n);
> 
> ## let's preconstruct these for speed
> dist = vector("double", end_i_for_fits)
> 
> f_nb <- function(par) {
+ 
+ 	mu = par[1];
+ 	size = par[2];
+ 
+   if ((mu <= 0) || (size <= 0))
+   {
+     return(0);
+   }
+   
+   cat(start_i_for_fits, " ", end_i_for_fits, "\n");
+   cat(mu, " ", size, "\n");
+   
+ 	dist<-c()
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+ 		dist[i] <- dnbinom(i, size=size, mu=mu);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (mu, size)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> 
> ## Fit negative binomial 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> nb_fit = NULL
> ## as.numeric prevents overflow in sums involving integers
> mean_estimate = sum((as.numeric(1:end_i_for_fits)*as.numeric(X.for.fits)))/sum(as.numeric(X.for.fits))
> 
> nb_fit_mu = -1
> nb_fit_size = -1
> try_size = 100000
> try_means_index = 1
> #This is a list of different means to test <-  sometimes the actual mean doesn't lead to a fit
> try_means = c(mean_estimate, 
+               end_i_for_fits, 
+               start_i_for_fits, 
+               1*(end_i_for_fits + start_i_for_fits)/4,
+               2*(end_i_for_fits + start_i_for_fits)/4,
+               3*(end_i_for_fits + start_i_for_fits)/4
+               )
>               
>               
> nb_fit = c()
> 
> while ( ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1)) && (try_size > 0.001) && (try_means_index <= length(try_means)))
+ {
+   try_size = try_size / 10
+   try_mean = try_means[try_means_index]
+ 
+   ## SIZE ESTIMATE from the censored data can be negative, so try various values instead
+   cat("Try Mean: ", try_mean, " Size: ", try_size, "\n")
+ 
+   try( suppressWarnings(nb_fit<-nlm(f_nb, c(try_mean, try_size), iterlim=1000, print.level=this.print.level)) )
+ 
+   nb_fit_mu = nb_fit$estimate[1];
+   nb_fit_size = nb_fit$estimate[2];
+ 
+   cat("Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, "\n")
+   
+   if (try_size <= 0.001) {
+     try_size = 100000
+     try_means_index = try_means_index + 1
+   }
+ }
Try Mean:  23.62549  Size:  10000 
11   35 
23.62549   10000 
11   35 
23.62549   10000 
11   35 
23.62551   10000 
11   35 
23.62549   10000.01 
11   35 
23.62924   10000 
11   35 
23.62927   10000 
11   35 
23.62924   10000.01 
11   35 
24.9867   10000 
11   35 
24.98673   10000 
11   35 
24.9867   10000.01 
11   35 
25.01831   10000 
11   35 
25.01834   10000 
11   35 
25.01831   10000.01 
11   35 
25.01977   10000 
11   35 
25.01979   10000 
11   35 
25.01977   10000.01 
11   35 
25.01977   10000 
11   35 
25.0198   10000 
11   35 
25.01977   10000.01 
Fit Mean:  25.01977  Size:  10000  Code:  2 
Try Mean:  23.62549  Size:  1000 
11   35 
23.62549   1000 
11   35 
23.62549   1000 
11   35 
23.62551   1000 
11   35 
23.62549   1000.001 
11   35 
23.6292   1000 
11   35 
23.62923   1000 
11   35 
23.6292   1000.001 
11   35 
25.00015   1000 
11   35 
25.00017   1000 
11   35 
25.00015   1000.001 
11   35 
25.0346   1000 
11   35 
25.03462   1000 
11   35 
25.0346   1000.001 
11   35 
25.03625   1000 
11   35 
25.03628   1000 
11   35 
25.03625   1000.001 
11   35 
25.03626   1000 
11   35 
25.03628   1000 
11   35 
25.03626   1000.001 
Fit Mean:  25.03626  Size:  1000  Code:  2 
Try Mean:  23.62549  Size:  100 
11   35 
23.62549   100 
11   35 
23.62549   100 
11   35 
23.62551   100 
11   35 
23.62549   100.0001 
11   35 
23.62884   100 
11   35 
23.62886   100 
11   35 
23.62884   100.0001 
11   35 
25.13609   100.0125 
11   35 
25.13612   100.0125 
11   35 
25.13609   100.0126 
11   35 
25.20294   100.018 
11   35 
25.20296   100.018 
11   35 
25.20294   100.0181 
11   35 
25.20803   100.0234 
11   35 
25.20806   100.0234 
11   35 
25.20803   100.0235 
11   35 
25.21332   100.039 
11   35 
25.21334   100.039 
11   35 
25.21332   100.0391 
11   35 
25.22353   100.0987 
11   35 
25.22355   100.0987 
11   35 
25.22353   100.0988 
11   35 
25.23877   100.2627 
11   35 
25.23879   100.2627 
11   35 
25.23877   100.2628 
11   35 
25.26332   100.7275 
11   35 
25.26334   100.7275 
11   35 
25.26332   100.7276 
11   35 
25.30015   101.9535 
11   35 
25.30018   101.9535 
11   35 
25.30015   101.9536 
11   35 
25.35173   105.0909 
11   35 
25.35176   105.0909 
11   35 
25.35173   105.091 
11   35 
25.41079   112.6133 
11   35 
25.41081   112.6133 
11   35 
25.41079   112.6134 
11   35 
25.44832   129.5091 
11   35 
25.44834   129.5091 
11   35 
25.44832   129.5092 
11   35 
25.40049   165.6128 
11   35 
25.40051   165.6128 
11   35 
25.40049   165.613 
11   35 
25.2069   231.0474 
11   35 
25.20693   231.0474 
11   35 
25.2069   231.0476 
11   35 
25.02541   299.1604 
11   35 
25.02544   299.1604 
11   35 
25.02541   299.1607 
11   35 
24.96766   345.2744 
11   35 
24.96768   345.2744 
11   35 
24.96766   345.2747 
11   35 
24.94222   423.381 
11   35 
24.94225   423.381 
11   35 
24.94222   423.3814 
11   35 
24.96845   551.0688 
11   35 
24.96847   551.0688 
11   35 
24.96845   551.0693 
11   35 
25.02378   722.6338 
11   35 
25.0238   722.6338 
11   35 
25.02378   722.6345 
11   35 
25.05827   916.9949 
11   35 
25.0583   916.9949 
11   35 
25.05827   916.9958 
11   35 
25.0674   1169.933 
11   35 
25.06742   1169.933 
11   35 
25.0674   1169.934 
11   35 
25.05406   1545.16 
11   35 
25.05409   1545.16 
11   35 
25.05406   1545.162 
11   35 
25.02992   2051.306 
11   35 
25.02994   2051.306 
11   35 
25.02992   2051.308 
11   35 
25.01213   2669.53 
11   35 
25.01216   2669.53 
11   35 
25.01213   2669.533 
11   35 
25.00541   3463.501 
11   35 
25.00543   3463.501 
11   35 
25.00541   3463.505 
11   35 
25.00855   4564.93 
11   35 
25.00858   4564.93 
11   35 
25.00855   4564.935 
11   35 
25.01669   6041.746 
11   35 
25.01672   6041.746 
11   35 
25.01669   6041.752 
11   35 
25.02326   7932.991 
11   35 
25.02329   7932.991 
11   35 
25.02326   7932.999 
11   35 
25.0255   10410.18 
11   35 
25.02553   10410.18 
11   35 
25.0255   10410.2 
11   35 
25.02369   13776.83 
11   35 
25.02372   13776.83 
11   35 
25.02369   13776.84 
11   35 
25.01995   18272.25 
11   35 
25.01998   18272.25 
11   35 
25.01995   18272.26 
11   35 
25.01684   24112.72 
11   35 
25.01687   24112.72 
11   35 
25.01684   24112.74 
11   35 
25.01559   31775.72 
11   35 
25.01562   31775.72 
11   35 
25.01559   31775.75 
11   35 
25.01611   42050.7 
11   35 
25.01614   42050.7 
11   35 
25.01611   42050.75 
11   35 
25.01751   55707.29 
11   35 
25.01754   55707.29 
11   35 
25.01751   55707.35 
11   35 
25.01873   73669.69 
11   35 
25.01876   73669.69 
11   35 
25.01873   73669.76 
11   35 
25.0192   97319.19 
11   35 
25.01922   97319.19 
11   35 
25.0192   97319.28 
11   35 
25.01893   128779.3 
11   35 
25.01895   128779.3 
11   35 
25.01893   128779.4 
11   35 
25.01829   171088.6 
11   35 
25.01831   171088.6 
11   35 
25.01829   171088.7 
11   35 
25.01774   225854 
11   35 
25.01776   225854 
11   35 
25.01774   225854.2 
11   35 
25.0175   299082 
11   35 
25.01753   299082 
11   35 
25.0175   299082.3 
11   35 
25.01758   400470.8 
11   35 
25.0176   400470.8 
11   35 
25.01758   400471.2 
11   35 
25.01779   503223.7 
11   35 
25.01781   503223.7 
11   35 
25.01779   503224.2 
11   35 
25.01794   605976.6 
11   35 
25.01797   605976.6 
11   35 
25.01794   605977.2 
11   35 
25.01802   708729.6 
11   35 
25.01805   708729.6 
11   35 
25.01802   708730.3 
11   35 
25.01804   811482.5 
11   35 
25.01807   811482.5 
11   35 
25.01804   811483.3 
11   35 
25.01804   914235.4 
11   35 
25.01806   914235.4 
11   35 
25.01804   914236.3 
Fit Mean:  25.01804  Size:  914235.4  Code:  5 
Try Mean:  23.62549  Size:  10 
11   35 
23.62549   10 
11   35 
23.62549   10 
11   35 
23.62551   10 
11   35 
23.62549   10.00001 
11   35 
23.62756   10.00066 
11   35 
23.62759   10.00066 
11   35 
23.62756   10.00067 
11   35 
27.34818   12.71358 
11   35 
27.3482   12.71358 
11   35 
27.34818   12.71359 
11   35 
27.46174   13.46828 
11   35 
27.46177   13.46828 
11   35 
27.46174   13.46829 
11   35 
27.14389   17.9009 
11   35 
27.14391   17.9009 
11   35 
27.14389   17.90091 
11   35 
25.09046   30.99439 
11   35 
25.09049   30.99439 
11   35 
25.09046   30.99442 
11   35 
25.25444   34.11583 
11   35 
25.25446   34.11583 
11   35 
25.25444   34.11586 
11   35 
25.24627   51.83305 
11   35 
25.24629   51.83305 
11   35 
25.24627   51.83311 
11   35 
25.29632   65.86037 
11   35 
25.29635   65.86037 
11   35 
25.29632   65.86043 
11   35 
25.06718   90.43105 
11   35 
25.0672   90.43105 
11   35 
25.06718   90.43114 
11   35 
25.2813   119.8339 
11   35 
25.28132   119.8339 
11   35 
25.2813   119.834 
11   35 
25.11329   156.4436 
11   35 
25.11332   156.4436 
11   35 
25.11329   156.4438 
11   35 
25.06563   204.3668 
11   35 
25.06565   204.3668 
11   35 
25.06563   204.367 
11   35 
25.07013   266.4037 
11   35 
25.07015   266.4037 
11   35 
25.07013   266.404 
11   35 
25.0609   347.8344 
11   35 
25.06093   347.8344 
11   35 
25.0609   347.8348 
11   35 
25.04983   455.1106 
11   35 
25.04986   455.1106 
11   35 
25.04983   455.1111 
11   35 
25.0423   596.2177 
11   35 
25.04233   596.2177 
11   35 
25.0423   596.2183 
11   35 
25.03643   782.3685 
11   35 
25.03645   782.3685 
11   35 
25.03643   782.3693 
11   35 
25.03198   1028.256 
11   35 
25.032   1028.256 
11   35 
25.03198   1028.257 
11   35 
25.02857   1353.394 
11   35 
25.02859   1353.394 
11   35 
25.02857   1353.395 
11   35 
25.02599   1783.608 
11   35 
25.02601   1783.608 
11   35 
25.02599   1783.61 
11   35 
25.02402   2353.115 
11   35 
25.02405   2353.115 
11   35 
25.02402   2353.117 
11   35 
25.02254   3107.22 
11   35 
25.02256   3107.22 
11   35 
25.02254   3107.223 
11   35 
25.02141   4105.934 
11   35 
25.02144   4105.934 
11   35 
25.02141   4105.938 
11   35 
25.02057   5428.742 
11   35 
25.02059   5428.742 
11   35 
25.02057   5428.747 
11   35 
25.01992   7180.933 
11   35 
25.01995   7180.933 
11   35 
25.01992   7180.94 
11   35 
25.01944   9502.021 
11   35 
25.01946   9502.021 
11   35 
25.01944   9502.03 
11   35 
25.01907   12576.54 
11   35 
25.0191   12576.54 
11   35 
25.01907   12576.56 
11   35 
25.0188   16649.45 
11   35 
25.01882   16649.45 
11   35 
25.0188   16649.46 
11   35 
25.01859   22045.25 
11   35 
25.01861   22045.25 
11   35 
25.01859   22045.27 
11   35 
25.01843   29191.31 
11   35 
25.01845   29191.31 
11   35 
25.01843   29191.34 
11   35 
25.01831   38660.86 
11   35 
25.01834   38660.86 
11   35 
25.01831   38660.89 
11   35 
25.01822   51198.9 
11   35 
25.01825   51198.9 
11   35 
25.01822   51198.95 
11   35 
25.01815   67798.84 
11   35 
25.01818   67798.84 
11   35 
25.01815   67798.91 
11   35 
25.0181   89847.16 
11   35 
25.01813   89847.16 
11   35 
25.0181   89847.25 
11   35 
25.01807   115501.9 
11   35 
25.01809   115501.9 
11   35 
25.01807   115502 
11   35 
25.01805   141156.6 
11   35 
25.01807   141156.6 
11   35 
25.01805   141156.7 
11   35 
25.01803   166811.3 
11   35 
25.01806   166811.3 
11   35 
25.01803   166811.4 
11   35 
25.01802   192466 
11   35 
25.01805   192466 
11   35 
25.01802   192466.2 
11   35 
25.01801   218120.7 
11   35 
25.01804   218120.7 
11   35 
25.01801   218120.9 
Fit Mean:  25.01801  Size:  218120.7  Code:  1 
> 
> cat("Final Fit Mean: ", nb_fit_mu, " Size: ", nb_fit_size, " Code: ", nb_fit$code, " Try Size: ", try_size, "\n")
Final Fit Mean:  25.01801  Size:  218120.7  Code:  1  Try Size:  10 
> 
> ## Fit failed = reset parameters so graphing and output code can recognize this
> if ((nb_fit_mu < 0) || (nb_fit_size < 0) || (nb_fit$code != 1))
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> 
> ## things can go wrong with fitting and we can still end up with invalid values
> 
> fit_nb = c()
> included_fract = 0
> if (nb_fit_mu > 0)
+ {
+   end_fract = pnbinom(end_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   start_fract = pnbinom(start_i_for_fits, mu = nb_fit_mu, size=nb_fit_size)
+   included_fract = end_fract-start_fract;
+ 
+   if (included_fract >= 0.01) {
+ 
+     ## Adjust so that we are back in full coords before making fit!!
+     if (num_per_bin > 1) 
+     {
+       nb_fit_mu = nb_fit_mu * num_per_bin
+     }
+     fit_nb = dnbinom(0:max(X$coverage), mu = nb_fit_mu, size=nb_fit_size)*inner_total/included_fract;
+   }
+ }
> 
> ## If an insufficient amount of fit was included, then invalidate it
> if (included_fract < 0.01)
+ {
+   nb_fit_mu = 0
+   nb_fit_size = 0
+ }
> 
> f_p <- function(par) {
+ 
+   lambda = par[1];
+ 
+   if (lambda <= 0)
+   {
+     return(0);
+   }
+   
+ 	total <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{	
+     #cat(i, " ", lambda, "\n");
+ 		dist[i] <- dpois(i, lambda=lambda);
+ 		total <- total + dist[i] 
+ 	}
+ 	#print (total)
+ 
+  	l <- 0;
+ 	for (i in start_i_for_fits:end_i_for_fits)
+ 	{
+ 		l <- l + ((X.for.fits[i]/inner_total)-(dist[i]/total))^2;
+ 	}
+ 	return(l);
+ }
> 
> 
> ## Fit Poisson 
> ## - allow fit to fail and set all params to zero/empty if that is the case
> 
> p_fit = NULL
> try(suppressWarnings(p_fit<-nlm(f_p, c(m), print.level=this.print.level)))
> 
> fit_p = c()
> if (!is.null(p_fit) && (p_fit$estimate[1] > 0))
+ {
+   #print (nb_fit$estimate[1])
+   p_fit_lambda = p_fit$estimate[1];
+   #print(0:max(X$coverage))
+ 
+   end_fract = ppois(end_i_for_fits, lambda = p_fit_lambda)
+   start_fract = ppois(start_i_for_fits, lambda = p_fit_lambda)
+   included_fract = end_fract-start_fract;
+ 
+   ## Adjust so that we are back in full coords before making fit!!
+   if (num_per_bin > 1) 
+   {
+     p_fit_lambda = p_fit_lambda * num_per_bin
+   }
+   fit_p<-dpois(0:max(X$coverage), lambda = p_fit_lambda)*inner_total/included_fract;
+ }
> 
> 
> ## Graphing
> ##
> ## don't graph very high values with very little coverage
> i<-max_i
> while (i <= length(X$n) && X$n[i]>0.01*max_n)
+ {		
+ 	i <- i+1;
+ }
> graph_end_i <-i
> 
> ## Ths leaves enough room to the right of the peak for the legend
> graph_end_i = max(floor(2.2 * max_i), graph_end_i);
> 
> ## graphics settings
> my_pch = 21
> my_col = "black";
> my_col_censored = "red";
> 
> if (pdf_output == 0) {
+   
+   ## bitmap() requires ghostscript to be installed.
+   ## taa=4, gaa=2 options NOT compatible with earlier R versions!
+   ## units = "px" NOT compatible with even earlier R versions!
+   
+   if(!capabilities(what = "png"))
+   {
+     ## fallback to ghostscript
+     bitmap(plot_file, height=6, width=7, type = "png16m", res = 72, pointsize=18)
+   } else {
+     ## use X11 function, which gives better resolution
+     png(plot_file, height=6, width=7, units ="in", res = 72, pointsize=18)
+     par(family="sans")
+   }
+ } else {
+   pdf(plot_file, height=6, width=7)
+   par(family="sans")
+ }
> 
> par(mar=c(5.5,7.5,3,1.5));
> 
> max_y = 0
> if (plot_poisson) {
+ 	max_y = max(X$n, fit_p, fit_nb)
+ } else {
+ 	max_y = max(X$n, fit_nb)
+ }
> 
> plot(0:10, 0:10, type="n", lty="solid", ylim=c(0, max_y)*1.05, xlim=c(0, graph_end_i), lwd=1, xaxs="i", yaxs="i", axes=F, las=1, main="Coverage Distribution at Unique-Only Positions", xlab="Coverage depth (reads)", ylab="", cex.lab=1.2, cex.axis=1.2)
> 
> mtext(side = 2, text = "Number of reference positions", line = 5.5, cex=1.2)
> 
> sciNotation <- function(x, digits = 1) {
+     if (length(x) > 1) {
+         return(append(sciNotation(x[1]), sciNotation(x[-1])))     
+ 	} 
+     if (!x) return(0) 
+ 
+ 	exponent <- floor(log10(x)) 
+     base <- round(x / 10^exponent, digits)     
+ 	as.expression(substitute(base %*% 10^exponent, list(base = base, exponent = exponent))) 
+ }
> 
> #axis(2, cex.lab=1.2, las=1, cex.axis=1.2, labels=T, at=(0:6)*50000)
> axis(2, cex.lab=1.2, las=1, cex.axis=1.2, at = axTicks(2), labels = sciNotation(axTicks(2), 1))
> axis(1, cex.lab=1.2, cex.axis=1.2, labels=T)
> box()
> 
> #graph the coverage as points
> fit_data <- subset(X, (coverage>=start_i) & (coverage<=end_i) );
> points(fit_data$coverage, fit_data$n, pch=my_pch, col=my_col, bg="white", cex=1.2)
> 
> #graph the censored coverage as red points
> cat(start_i, " ", end_i, "\n", sep="")
11 35
> 
> censored_data <- subset(X, (coverage<start_i) | (coverage>end_i) );
> points(censored_data$coverage, censored_data$n, pch=my_pch, col=my_col_censored, bg="white", cex=1.2)
> 
> #graph the poisson fit IF REQUESTED
> if (plot_poisson) {
+ 	lines(0:max(X$coverage), fit_p, lwd=3, lty="22", col="black");
+ }
> 
> #graph the negative binomial fit
> if (nb_fit_mu > 0) {
+   lines(0:max(X$coverage), fit_nb, lwd=3, col="black");
+ }
> 
> if (plot_poisson) {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial", "Poisson"), lty=c("blank","blank","solid","22"), lwd=c(1,1,2,2), pch=c(my_pch, my_pch, -1, -1), col=c("black", "red", "black", "black"), bty="n")
+ } else {
+ 	legend("topright", c("Coverage distribution", "Censored data", "Negative binomial"), lty=c("blank","blank","solid"), lwd=c(1,1,2), pch=c(my_pch, my_pch, -1), col=c("black", "red", "black"), bty="n")
+ }
> 
> dev.off()
null device 
          1 
> 
> ## Fit the marginal value that we use for propagating deletions
> 
> if (nb_fit_mu > 0) {
+   cat(nb_fit_size, " ", nb_fit_mu, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = nb_fit_size, mu = nb_fit_mu))
+ } else {
+   cat("Fallback to calculating off an estimate of just variance = mu + mu^2/size\n")
+   size_estimate = (1/(v-m))*(m*m)
+   cat("Mu estimate=", m," Size estimate =", size_estimate, "\n")
+   deletion_propagation_coverage = suppressWarnings(qnbinom(deletion_propagation_pr_cutoff, size = size_estimate, mu = m))
+   if (is.na(deletion_propagation_coverage) || is.nan(deletion_propagation_coverage) || (deletion_propagation_coverage < 1)) {
+     cat("Double fallback to calculating as just 10% of the mean\n")
+     deletion_propagation_coverage = m * 0.1
+   }
+ }
218120.7   25.01801 
> 
> #Don't allow one read to indicate non-deleted regions
> if (deletion_propagation_coverage < 1) {
+     deletion_propagation_coverage = 1
+ }
> 
> #This works fine with the negative values
> #If we have both low fit coverage and low straight average coverage then we're deleted...
> if ( (nb_fit_mu <= 3) && (m <= 3) ) {
+   deletion_propagation_coverage = -1
+ }
> 
> #print out statistics
> 
> print(nb_fit_size);
[1] 218120.7
> print(nb_fit_mu);
[1] 25.01801
> 
> print(m)
[1] 25.90101
> print(v)
[1] 63.11455
> print(D)
[1] 2.436761
> 
> print(deletion_propagation_coverage)
[1] 12
> 
> warnings()
> 
